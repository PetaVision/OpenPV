<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PetaVision: PV::ImprintConn Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="PetaVision"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PetaVision
   &#160;<span id="projectnumber">Alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classPV_1_1ImprintConn.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">PV::ImprintConn Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for PV::ImprintConn:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPV_1_1ImprintConn.png" usemap="#PV::ImprintConn_map" alt=""/>
  <map id="PV::ImprintConn_map" name="PV::ImprintConn_map">
<area href="classPV_1_1HyPerConn.html" alt="PV::HyPerConn" shape="rect" coords="0,56,127,80"/>
<area href="classPV_1_1BaseConnection.html" alt="PV::BaseConnection" shape="rect" coords="0,0,127,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a784aa2fb9578f11209f49ae14eaeda1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a784aa2fb9578f11209f49ae14eaeda1c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ImprintConn</b> (const char *name, <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *hc, <a class="el" href="classPV_1_1InitWeights.html">InitWeights</a> *weightInitializer=NULL, <a class="el" href="classPV_1_1NormalizeBase.html">NormalizeBase</a> *weightNormalizer=NULL)</td></tr>
<tr class="separator:a784aa2fb9578f11209f49ae14eaeda1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9c31116b372a5381c97ba8d0e5f622"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c9c31116b372a5381c97ba8d0e5f622"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>addClone</b> (<a class="el" href="classPV_1_1PlasticCloneConn.html">PlasticCloneConn</a> *conn)</td></tr>
<tr class="separator:a9c9c31116b372a5381c97ba8d0e5f622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ec4d55a7a2fea63397c1f2572e114d"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1ImprintConn.html#ab9ec4d55a7a2fea63397c1f2572e114d">allocateDataStructures</a> ()</td></tr>
<tr class="separator:ab9ec4d55a7a2fea63397c1f2572e114d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5257b1cbc2eff50e5a6ae15205203e4c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1ImprintConn.html#a5257b1cbc2eff50e5a6ae15205203e4c">checkpointRead</a> (const char *cpDir, double *timef)</td></tr>
<tr class="separator:a5257b1cbc2eff50e5a6ae15205203e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ce443cf4cfc00219f9834c19c022d6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1ImprintConn.html#ae2ce443cf4cfc00219f9834c19c022d6">checkpointWrite</a> (const char *cpDir)</td></tr>
<tr class="separator:ae2ce443cf4cfc00219f9834c19c022d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a5cc03609f6d283f62410c7243e019"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a18a5cc03609f6d283f62410c7243e019">communicateInitInfo</a> ()</td></tr>
<tr class="separator:a18a5cc03609f6d283f62410c7243e019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e19d245ecb33c404a707c0b5285f017"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e19d245ecb33c404a707c0b5285f017"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>computeNewWeightUpdateTime</b> (double time, double currentUpdateTime)</td></tr>
<tr class="separator:a8e19d245ecb33c404a707c0b5285f017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fb1171bdf64d6454f2e5cc180c347d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8fb1171bdf64d6454f2e5cc180c347d"></a>
PVPatch ***&#160;</td><td class="memItemRight" valign="bottom"><b>convertPreSynapticWeights</b> (double time)</td></tr>
<tr class="separator:aa8fb1171bdf64d6454f2e5cc180c347d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0636ad1315a3582d6a8f7291f27f50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc0636ad1315a3582d6a8f7291f27f50"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>dataIndexToUnitCellIndex</b> (int dataIndex, int *kx=NULL, int *ky=NULL, int *kf=NULL)</td></tr>
<tr class="separator:abc0636ad1315a3582d6a8f7291f27f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045e844e9e9e18802d48d092fbc7a64a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a045e844e9e9e18802d48d092fbc7a64a"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>defaultUpdateInd_dW</b> (int arbor_ID, int kExt)</td></tr>
<tr class="separator:a045e844e9e9e18802d48d092fbc7a64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6224b373cdf3ed2945009b05384045e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a6224b373cdf3ed2945009b05384045e9">deliver</a> ()</td></tr>
<tr class="separator:a6224b373cdf3ed2945009b05384045e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1353fcb2e5d64021e256c074aebe70f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1353fcb2e5d64021e256c074aebe70f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>deliverOnePostNeuronActivity</b> (int arborID, int kTargetExt, int inSy, float *activityStartBuf, pvdata_t *gSynPatchPos, float dt_factor, uint4 *rngPtr)</td></tr>
<tr class="separator:aa1353fcb2e5d64021e256c074aebe70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3cded8f8081a2ceca6cdd876a8388e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e3cded8f8081a2ceca6cdd876a8388e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>deliverOnePreNeuronActivity</b> (int patchIndex, int arbor, pvadata_t a, pvgsyndata_t *postBufferStart, void *auxPtr)</td></tr>
<tr class="separator:a8e3cded8f8081a2ceca6cdd876a8388e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b52df3960d65adc7ea54cc9d96d1adf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a9b52df3960d65adc7ea54cc9d96d1adf">finalizeUpdate</a> (double timed, double dt)</td></tr>
<tr class="separator:a9b52df3960d65adc7ea54cc9d96d1adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96c1b9a2d0f0db54a814744d9044f0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab96c1b9a2d0f0db54a814744d9044f0a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fPatchSize</b> ()</td></tr>
<tr class="separator:ab96c1b9a2d0f0db54a814744d9044f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fec7baf4333f5cb9562f586c966c854"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fec7baf4333f5cb9562f586c966c854"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fPatchStride</b> ()</td></tr>
<tr class="separator:a2fec7baf4333f5cb9562f586c966c854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc9ae17ff84e65c06c63241d02af83c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfc9ae17ff84e65c06c63241d02af83c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fPostPatchSize</b> ()</td></tr>
<tr class="separator:acfc9ae17ff84e65c06c63241d02af83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397b70f196a792b5dc7accba3ab05602"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a397b70f196a792b5dc7accba3ab05602"></a>
pvwdata_t *&#160;</td><td class="memItemRight" valign="bottom"><b>get_dwData</b> (int arborId, int patchIndex)</td></tr>
<tr class="separator:a397b70f196a792b5dc7accba3ab05602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8eef12a40064f1851bb6871fc67d5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b8eef12a40064f1851bb6871fc67d5d"></a>
pvwdata_t *&#160;</td><td class="memItemRight" valign="bottom"><b>get_dwDataHead</b> (int arborId, int dataIndex)</td></tr>
<tr class="separator:a1b8eef12a40064f1851bb6871fc67d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05f8efc04759694c4a91c901244e1d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa05f8efc04759694c4a91c901244e1d5"></a>
pvwdata_t *&#160;</td><td class="memItemRight" valign="bottom"><b>get_dwDataStart</b> (int arborId)</td></tr>
<tr class="separator:aa05f8efc04759694c4a91c901244e1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08ee1f54a52ea2812c63d67ea2eb942"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac08ee1f54a52ea2812c63d67ea2eb942"></a>
pvwdata_t *&#160;</td><td class="memItemRight" valign="bottom"><b>get_wData</b> (int arborId, int patchIndex)</td></tr>
<tr class="separator:ac08ee1f54a52ea2812c63d67ea2eb942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af293ac71ac2057da678058a4c2930b04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af293ac71ac2057da678058a4c2930b04"></a>
pvwdata_t *&#160;</td><td class="memItemRight" valign="bottom"><b>get_wDataHead</b> (int arborId, int dataIndex)</td></tr>
<tr class="separator:af293ac71ac2057da678058a4c2930b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceabc11964a9617302e90cd6eaf7cb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ceabc11964a9617302e90cd6eaf7cb4"></a>
pvwdata_t *&#160;</td><td class="memItemRight" valign="bottom"><b>get_wDataStart</b> (int arborId)</td></tr>
<tr class="separator:a4ceabc11964a9617302e90cd6eaf7cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79635fffbb429407363df3c17c780e46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79635fffbb429407363df3c17c780e46"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getAllocDeviceWeights</b> ()</td></tr>
<tr class="separator:a79635fffbb429407363df3c17c780e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6701652525a7974a4a0c92c33b0861"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c6701652525a7974a4a0c92c33b0861"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getAllocPostDeviceWeights</b> ()</td></tr>
<tr class="separator:a4c6701652525a7974a4a0c92c33b0861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f542fc8760ae4610e5ea71cd93ae69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9f542fc8760ae4610e5ea71cd93ae69"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getAPostOffset</b> (int kPre, int arborId)</td></tr>
<tr class="separator:ab9f542fc8760ae4610e5ea71cd93ae69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7fa97e4e991952782e2d5267dbad6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b7fa97e4e991952782e2d5267dbad6c"></a>
ChannelType&#160;</td><td class="memItemRight" valign="bottom"><b>getChannel</b> ()</td></tr>
<tr class="separator:a3b7fa97e4e991952782e2d5267dbad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be0fa26cb77eeb9639fe050a321d94e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a4be0fa26cb77eeb9639fe050a321d94e">getConnectionId</a> ()</td></tr>
<tr class="separator:a4be0fa26cb77eeb9639fe050a321d94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4156c5a76ca32f25d7c2ed3b2b4d18ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a4156c5a76ca32f25d7c2ed3b2b4d18ab">getConvertRateToSpikeCount</a> ()</td></tr>
<tr class="separator:a4156c5a76ca32f25d7c2ed3b2b4d18ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9347ed2d5346fede4e490351926b5da5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a9347ed2d5346fede4e490351926b5da5">getDataStructuresAllocatedFlag</a> ()</td></tr>
<tr class="separator:a9347ed2d5346fede4e490351926b5da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe70c6d11aa83fd6c5a5c0c3bda73e72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#afe70c6d11aa83fd6c5a5c0c3bda73e72">getDelay</a> (int arbor)</td></tr>
<tr class="separator:afe70c6d11aa83fd6c5a5c0c3bda73e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad507825984a33268cc2c65baf8aa38d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad507825984a33268cc2c65baf8aa38d1"></a>
PVCuda::CudaBuffer *&#160;</td><td class="memItemRight" valign="bottom"><b>getDeviceGSynPatchStart</b> ()</td></tr>
<tr class="separator:ad507825984a33268cc2c65baf8aa38d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559e082d9e1af16b3572a81a80cb7a6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a559e082d9e1af16b3572a81a80cb7a6b"></a>
PVCuda::CudaBuffer *&#160;</td><td class="memItemRight" valign="bottom"><b>getDevicePatches</b> ()</td></tr>
<tr class="separator:a559e082d9e1af16b3572a81a80cb7a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a02419c8b3dbc2eea3ca4daf17c90ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a02419c8b3dbc2eea3ca4daf17c90ad"></a>
virtual PVCuda::CudaBuffer *&#160;</td><td class="memItemRight" valign="bottom"><b>getDeviceWData</b> ()</td></tr>
<tr class="separator:a7a02419c8b3dbc2eea3ca4daf17c90ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e04ade4198cc15eb9705cf83359bc2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e04ade4198cc15eb9705cf83359bc2c"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>getDWMax</b> ()</td></tr>
<tr class="separator:a9e04ade4198cc15eb9705cf83359bc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365bcf496dc77e7f2b07e797d3181954"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a365bcf496dc77e7f2b07e797d3181954"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getGSynPatchStart</b> (int kPre, int arborId)</td></tr>
<tr class="separator:a365bcf496dc77e7f2b07e797d3181954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08138c760991d5ae174db5593859d4bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08138c760991d5ae174db5593859d4bc"></a>
size_t **&#160;</td><td class="memItemRight" valign="bottom"><b>getGSynPatchStart</b> ()</td></tr>
<tr class="separator:a08138c760991d5ae174db5593859d4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764a2087e925f175e24bd144f4c9c062"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a764a2087e925f175e24bd144f4c9c062">getInitialValuesSetFlag</a> ()</td></tr>
<tr class="separator:a764a2087e925f175e24bd144f4c9c062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad617960920014f253c2244a915ce5543"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ad617960920014f253c2244a915ce5543">getInitInfoCommunicatedFlag</a> ()</td></tr>
<tr class="separator:ad617960920014f253c2244a915ce5543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e8b733d9b4616d0e4c9e99ab71b226"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e8b733d9b4616d0e4c9e99ab71b226"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getKeepKernelsSynchronized</b> ()</td></tr>
<tr class="separator:a75e8b733d9b4616d0e4c9e99ab71b226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c908e5664c2103f4ff52026ab2f7b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2c908e5664c2103f4ff52026ab2f7b7"></a>
<a class="el" href="classPVCuda_1_1CudaRecvPost.html">PVCuda::CudaRecvPost</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getKrRecvPost</b> ()</td></tr>
<tr class="separator:aa2c908e5664c2103f4ff52026ab2f7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2177aa1b7f69ee90dd9fb3e78bfb5cee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2177aa1b7f69ee90dd9fb3e78bfb5cee"></a>
<a class="el" href="classPVCuda_1_1CudaRecvPre.html">PVCuda::CudaRecvPre</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getKrRecvPre</b> ()</td></tr>
<tr class="separator:a2177aa1b7f69ee90dd9fb3e78bfb5cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f6170d6e16ac9f53e4e0fce67b16e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7f6170d6e16ac9f53e4e0fce67b16e4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getLastUpdateTime</b> ()</td></tr>
<tr class="separator:ae7f6170d6e16ac9f53e4e0fce67b16e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829c6e9c1ea72edce9c41992c295703e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a829c6e9c1ea72edce9c41992c295703e">getName</a> ()</td></tr>
<tr class="separator:a829c6e9c1ea72edce9c41992c295703e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bcee990f0a6dd2f772057573006924"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83bcee990f0a6dd2f772057573006924"></a>
<a class="el" href="classPV_1_1NormalizeBase.html">NormalizeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getNormalizer</b> ()</td></tr>
<tr class="separator:a83bcee990f0a6dd2f772057573006924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdc0fd6695ff96c5edbfac77089abfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cdc0fd6695ff96c5edbfac77089abfe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumDataPatches</b> ()</td></tr>
<tr class="separator:a8cdc0fd6695ff96c5edbfac77089abfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5901ea5222187c6d9664c43f29c37316"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5901ea5222187c6d9664c43f29c37316"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumFLocal</b> ()</td></tr>
<tr class="separator:a5901ea5222187c6d9664c43f29c37316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6549daefcd4515a36256e1c01533136"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6549daefcd4515a36256e1c01533136"></a>
virtual long&#160;</td><td class="memItemRight" valign="bottom"><b>getNumKernelActivations</b> (int arbor_ID, int kernelIndex, int patchindex)</td></tr>
<tr class="separator:ae6549daefcd4515a36256e1c01533136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b7138f8561ba0dd30bfc51ce9bc72e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26b7138f8561ba0dd30bfc51ce9bc72e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumWeightPatches</b> ()</td></tr>
<tr class="separator:a26b7138f8561ba0dd30bfc51ce9bc72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7857421b9232b5f95edfa1466442389"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7857421b9232b5f95edfa1466442389"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumXLocal</b> ()</td></tr>
<tr class="separator:af7857421b9232b5f95edfa1466442389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8587e9fbb05871862fd8616d1ce0dc83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8587e9fbb05871862fd8616d1ce0dc83"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumYLocal</b> ()</td></tr>
<tr class="separator:a8587e9fbb05871862fd8616d1ce0dc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4b40893e9e1285c43cd407d4958bc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#aba4b40893e9e1285c43cd407d4958bc0">getParent</a> ()</td></tr>
<tr class="separator:aba4b40893e9e1285c43cd407d4958bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2915e11f17685dbb4f338467f1515f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2915e11f17685dbb4f338467f1515f0"></a>
virtual int *&#160;</td><td class="memItemRight" valign="bottom"><b>getPatchToDataLUT</b> ()</td></tr>
<tr class="separator:ac2915e11f17685dbb4f338467f1515f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1886796b49fad4c8818e02ce3ec6c337"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1886796b49fad4c8818e02ce3ec6c337"></a>
pvwdata_t *&#160;</td><td class="memItemRight" valign="bottom"><b>getPlasticIncr</b> (int kPre, int arborId)</td></tr>
<tr class="separator:a1886796b49fad4c8818e02ce3ec6c337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc538ab995a555a1c31f5737c823fcbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc538ab995a555a1c31f5737c823fcbe"></a>
virtual <a class="el" href="structPVLayerCube__.html">PVLayerCube</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getPlasticityDecrement</b> ()</td></tr>
<tr class="separator:adc538ab995a555a1c31f5737c823fcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5885dab7c1de917eb154686e1d24e5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5885dab7c1de917eb154686e1d24e5e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getPlasticityFlag</b> ()</td></tr>
<tr class="separator:ae5885dab7c1de917eb154686e1d24e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41b3bfa3e307b90a82278f77fa1fd71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af41b3bfa3e307b90a82278f77fa1fd71"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getPost</b> ()</td></tr>
<tr class="separator:af41b3bfa3e307b90a82278f77fa1fd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2740ba04af485deae6023832b32320"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade2740ba04af485deae6023832b32320"></a>
const <a class="el" href="structPVPatchStrides__.html">PVPatchStrides</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getPostExtStrides</b> ()</td></tr>
<tr class="separator:ade2740ba04af485deae6023832b32320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd989c8655830efd1bbc5d0d8068657f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd989c8655830efd1bbc5d0d8068657f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getPostLayerName</b> ()</td></tr>
<tr class="separator:abd989c8655830efd1bbc5d0d8068657f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdddb3f6004287c0322076a0213124d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcdddb3f6004287c0322076a0213124d"></a>
const <a class="el" href="structPVPatchStrides__.html">PVPatchStrides</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getPostNonextStrides</b> ()</td></tr>
<tr class="separator:abcdddb3f6004287c0322076a0213124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ce3d70fd35bf76604633e6a5764242"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0ce3d70fd35bf76604633e6a5764242"></a>
virtual long *&#160;</td><td class="memItemRight" valign="bottom"><b>getPostToPreActivity</b> ()</td></tr>
<tr class="separator:af0ce3d70fd35bf76604633e6a5764242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01b5de07581cb4989e617d08c2ef77e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af01b5de07581cb4989e617d08c2ef77e"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getPre</b> ()</td></tr>
<tr class="separator:af01b5de07581cb4989e617d08c2ef77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5c7e8040d583f50f1e903618a3cf68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec5c7e8040d583f50f1e903618a3cf68"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getPreDataLocal</b> ()</td></tr>
<tr class="separator:aec5c7e8040d583f50f1e903618a3cf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8183d3bbd51d0a21c50ee31e32d7d138"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8183d3bbd51d0a21c50ee31e32d7d138"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getPreLayerName</b> ()</td></tr>
<tr class="separator:a8183d3bbd51d0a21c50ee31e32d7d138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49ddb924dac5074dee88d73d722cc61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac49ddb924dac5074dee88d73d722cc61"></a>
GSynAccumulateType&#160;</td><td class="memItemRight" valign="bottom"><b>getPvpatchAccumulateType</b> ()</td></tr>
<tr class="separator:ac49ddb924dac5074dee88d73d722cc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400fc632565a2f56e08058d05083b7d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a400fc632565a2f56e08058d05083b7d9"></a>
uint4 *&#160;</td><td class="memItemRight" valign="bottom"><b>getRandState</b> (int index)</td></tr>
<tr class="separator:a400fc632565a2f56e08058d05083b7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b875e9de5267029f3675a9cd781b39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8b875e9de5267029f3675a9cd781b39"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getReceiveGpu</b> ()</td></tr>
<tr class="separator:af8b875e9de5267029f3675a9cd781b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb80255bb361af08d2083794080e01b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb80255bb361af08d2083794080e01b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getSelfFlag</b> ()</td></tr>
<tr class="separator:abb80255bb361af08d2083794080e01b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ff6069821e9664e941f80168ba87a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22ff6069821e9664e941f80168ba87a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getShrinkPatches_flag</b> ()</td></tr>
<tr class="separator:a22ff6069821e9664e941f80168ba87a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c39a80e218d029140cb1a44fe7fd3a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c39a80e218d029140cb1a44fe7fd3a7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getUpdateGSynFromPostPerspective</b> ()</td></tr>
<tr class="separator:a0c39a80e218d029140cb1a44fe7fd3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afdaa1c7b2a9a6799b05f5c02a81d92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9afdaa1c7b2a9a6799b05f5c02a81d92"></a>
<a class="el" href="classPV_1_1InitWeights.html">InitWeights</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getWeightInitializer</b> ()</td></tr>
<tr class="separator:a9afdaa1c7b2a9a6799b05f5c02a81d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7683a9ce0739e5782389bf12b2667ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7683a9ce0739e5782389bf12b2667ea"></a>
virtual PVPatch *&#160;</td><td class="memItemRight" valign="bottom"><b>getWeights</b> (int kPre, int arborId)</td></tr>
<tr class="separator:ab7683a9ce0739e5782389bf12b2667ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65954929f585bcbcd02428ebdec97f08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65954929f585bcbcd02428ebdec97f08"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getWeightUpdatePeriod</b> ()</td></tr>
<tr class="separator:a65954929f585bcbcd02428ebdec97f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53d9a0c23482121a5f211f9c112a5f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae53d9a0c23482121a5f211f9c112a5f7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getWeightUpdateTime</b> ()</td></tr>
<tr class="separator:ae53d9a0c23482121a5f211f9c112a5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87773ccfc7e240d78a0421ef4dd8f97b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a87773ccfc7e240d78a0421ef4dd8f97b">getWMax</a> ()</td></tr>
<tr class="separator:a87773ccfc7e240d78a0421ef4dd8f97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e248fc2d82a06bbec93c397bdb51e3a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a6e248fc2d82a06bbec93c397bdb51e3a">getWMin</a> ()</td></tr>
<tr class="separator:a6e248fc2d82a06bbec93c397bdb51e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bc2336d04e0264cee431d43eae5a1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04bc2336d04e0264cee431d43eae5a1d"></a>
pvwdata_t *&#160;</td><td class="memItemRight" valign="bottom"><b>getWPostData</b> (int arbor, int patchIndex)</td></tr>
<tr class="separator:a04bc2336d04e0264cee431d43eae5a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91faef4a22e3c8257906c415abea6ba0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91faef4a22e3c8257906c415abea6ba0"></a>
pvwdata_t *&#160;</td><td class="memItemRight" valign="bottom"><b>getWPostData</b> (int arbor)</td></tr>
<tr class="separator:a91faef4a22e3c8257906c415abea6ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ac29005c37aa361c70c7e3e2a03339"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43ac29005c37aa361c70c7e3e2a03339"></a>
PVPatch *&#160;</td><td class="memItemRight" valign="bottom"><b>getWPostPatches</b> (int arbor, int patchIndex)</td></tr>
<tr class="separator:a43ac29005c37aa361c70c7e3e2a03339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556aa9907b6bd34efb829825fb4d96cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState</a> ()</td></tr>
<tr class="separator:a556aa9907b6bd34efb829825fb4d96cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1cd71c6fd576d04764d62b546fa963"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d1cd71c6fd576d04764d62b546fa963"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>initPatchToDataLUT</b> ()</td></tr>
<tr class="separator:a6d1cd71c6fd576d04764d62b546fa963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3e8145f1b9e1210935aeb4732c1df6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#afc3e8145f1b9e1210935aeb4732c1df6">insertProbe</a> (<a class="el" href="classPV_1_1BaseConnectionProbe.html">BaseConnectionProbe</a> *p)</td></tr>
<tr class="separator:afc3e8145f1b9e1210935aeb4732c1df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcc2c5884ce0776d49e41767ef45797"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#acdcc2c5884ce0776d49e41767ef45797">ioParams</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="separator:acdcc2c5884ce0776d49e41767ef45797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2b4bf71aab2681497c6be242d695ba"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#acc2b4bf71aab2681497c6be242d695ba">maxWeight</a> (int arborId=0)</td></tr>
<tr class="separator:acc2b4bf71aab2681497c6be242d695ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddf6eccc1fc0db72e0790736e11ff1e"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a3ddf6eccc1fc0db72e0790736e11ff1e">minWeight</a> (int arborId=0)</td></tr>
<tr class="separator:a3ddf6eccc1fc0db72e0790736e11ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a574b1184f310e9e0f16f1ccf4ce0a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#ab1a574b1184f310e9e0f16f1ccf4ce0a">needUpdate</a> (double time, double dt)</td></tr>
<tr class="separator:ab1a574b1184f310e9e0f16f1ccf4ce0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac56436c8219192a954518a263d19dcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac56436c8219192a954518a263d19dcb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfAxonalArborLists</b> ()</td></tr>
<tr class="separator:aac56436c8219192a954518a263d19dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fb1e130c43fed1d4104aa85ce3fb58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a62fb1e130c43fed1d4104aa85ce3fb58">outputProbeParams</a> ()</td></tr>
<tr class="separator:a62fb1e130c43fed1d4104aa85ce3fb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fbf973234d44386f383062e7968cb2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a52fbf973234d44386f383062e7968cb2">outputState</a> (double time, bool last=false)</td></tr>
<tr class="separator:a52fbf973234d44386f383062e7968cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff74c8ce3b97884f1a5c8d98f015440"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeff74c8ce3b97884f1a5c8d98f015440"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>patchIndexToDataIndex</b> (int patchIndex, int *kx=NULL, int *ky=NULL, int *kf=NULL)</td></tr>
<tr class="separator:aeff74c8ce3b97884f1a5c8d98f015440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56989e4a531c4ed12febee880a580fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac56989e4a531c4ed12febee880a580fb"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>patchToDataLUT</b> (int patchIndex)</td></tr>
<tr class="separator:ac56989e4a531c4ed12febee880a580fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a590d2bc7fd4f3f986278780f6ff69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4a590d2bc7fd4f3f986278780f6ff69"></a>
PVPatch ****&#160;</td><td class="memItemRight" valign="bottom"><b>point2PreSynapticWeights</b> ()</td></tr>
<tr class="separator:aa4a590d2bc7fd4f3f986278780f6ff69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1508ca0356c7a1fa1c5501c314e7eff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1508ca0356c7a1fa1c5501c314e7eff7"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>postSynapticLayer</b> ()</td></tr>
<tr class="separator:a1508ca0356c7a1fa1c5501c314e7eff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa967ab7bca24afae03b3cabe9a141fc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#aa967ab7bca24afae03b3cabe9a141fc3">postSynapticPatchHead</a> (int kPre, int *kxPostOut, int *kyPostOut, int *kfPostOut, int *dxOut, int *dyOut, int *nxpOut, int *nypOut)</td></tr>
<tr class="separator:aa967ab7bca24afae03b3cabe9a141fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa462c5ad2cedde5a4626b5bb665aa13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa462c5ad2cedde5a4626b5bb665aa13"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>preSynapticLayer</b> ()</td></tr>
<tr class="separator:afa462c5ad2cedde5a4626b5bb665aa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f0ecd356e28f638f2d646f30c933bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a55f0ecd356e28f638f2d646f30c933bb">preSynapticPatchHead</a> (int kxPost, int kyPost, int kfPost, int *kxPre, int *kyPre)</td></tr>
<tr class="separator:a55f0ecd356e28f638f2d646f30c933bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb94304db414d14e71d71f98b90192e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb94304db414d14e71d71f98b90192e3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>reduceNumKernelActivations</b> ()</td></tr>
<tr class="separator:acb94304db414d14e71d71f98b90192e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6b6c3d8085b8258521b089283984aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef6b6c3d8085b8258521b089283984aa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setAllocDeviceWeights</b> ()</td></tr>
<tr class="separator:aef6b6c3d8085b8258521b089283984aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f684948746a53c7760d1ac5b7d9b7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08f684948746a53c7760d1ac5b7d9b7a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setAllocPostDeviceWeights</b> ()</td></tr>
<tr class="separator:a08f684948746a53c7760d1ac5b7d9b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f62714f2f1410c51bcdd4fe2214920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a63f62714f2f1410c51bcdd4fe2214920">setDataStructuresAllocatedFlag</a> ()</td></tr>
<tr class="separator:a63f62714f2f1410c51bcdd4fe2214920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1018ce03f2f245ba8a46c3e86ca66842"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1018ce03f2f245ba8a46c3e86ca66842"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setDeviceWData</b> (PVCuda::CudaBuffer *inBuf)</td></tr>
<tr class="separator:a1018ce03f2f245ba8a46c3e86ca66842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f94f2c5bc97b5c5a9697aff6bf83355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a3f94f2c5bc97b5c5a9697aff6bf83355">setInitialValuesSetFlag</a> ()</td></tr>
<tr class="separator:a3f94f2c5bc97b5c5a9697aff6bf83355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf50b01e3b0260d971801edafcbb3e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#afcf50b01e3b0260d971801edafcbb3e2">setInitInfoCommunicatedFlag</a> ()</td></tr>
<tr class="separator:afcf50b01e3b0260d971801edafcbb3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91af0e9457253247be70b9caa4159b70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91af0e9457253247be70b9caa4159b70"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNeedAllocPostWeights</b> (bool inBool)</td></tr>
<tr class="separator:a91af0e9457253247be70b9caa4159b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ad71488871fdb6175d46c67aa820e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2ad71488871fdb6175d46c67aa820e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNeedPost</b> (bool inBool)</td></tr>
<tr class="separator:ae2ad71488871fdb6175d46c67aa820e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c652564c1b963e80c4f7d5021d246ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c652564c1b963e80c4f7d5021d246ed"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>shrinkPatch</b> (int kExt, int arborId)</td></tr>
<tr class="separator:a2c652564c1b963e80c4f7d5021d246ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5407b0a17ec4caa0943efd729f3f307"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5407b0a17ec4caa0943efd729f3f307"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>shrinkPatches</b> (int arborId)</td></tr>
<tr class="separator:ad5407b0a17ec4caa0943efd729f3f307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbebb8720d08d316c7d62950466c28b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cbebb8720d08d316c7d62950466c28b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sumWeights</b> (int nx, int ny, int offset, pvwdata_t *dataStart, double *sum, double *sum2, float *maxVal)</td></tr>
<tr class="separator:a1cbebb8720d08d316c7d62950466c28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ff94a107c8463c829624bd87108ba9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41ff94a107c8463c829624bd87108ba9"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>update_dW</b> (int arbor_ID)</td></tr>
<tr class="separator:a41ff94a107c8463c829624bd87108ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd875d4f9ac054a35fc9205968878b6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd875d4f9ac054a35fc9205968878b6f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>updateState</b> (double time, double dt)</td></tr>
<tr class="separator:acd875d4f9ac054a35fc9205968878b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb44e745059789fdd528880bcdf64fd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#adfb44e745059789fdd528880bcdf64fd">updateStateWrapper</a> (double time, double dt)</td></tr>
<tr class="separator:adfb44e745059789fdd528880bcdf64fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1f85e2953b0e0a06853a163b8903d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f1f85e2953b0e0a06853a163b8903d2"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>updateWeights</b> (int arbor_ID)</td></tr>
<tr class="separator:a1f1f85e2953b0e0a06853a163b8903d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684061069df2cfa4f03681565cf24782"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a684061069df2cfa4f03681565cf24782"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>usingSharedWeights</b> ()</td></tr>
<tr class="separator:a684061069df2cfa4f03681565cf24782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4e602b7ca6223a222ff1385a6828ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd4e602b7ca6223a222ff1385a6828ee"></a>
PVPatch **&#160;</td><td class="memItemRight" valign="bottom"><b>weights</b> (int arborId=0)</td></tr>
<tr class="separator:acd4e602b7ca6223a222ff1385a6828ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d91f715cbef61227d2a21914a61189"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75d91f715cbef61227d2a21914a61189"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>writePostSynapticWeights</b> (double time, bool last)</td></tr>
<tr class="separator:a75d91f715cbef61227d2a21914a61189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaea56832055018220a66b4a9af92c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdaea56832055018220a66b4a9af92c6"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>writeTextWeights</b> (const char *filename, int k)</td></tr>
<tr class="separator:afdaea56832055018220a66b4a9af92c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58761a72c9fce387f3751e483dfdfb7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58761a72c9fce387f3751e483dfdfb7b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>writeTextWeightsExtra</b> (<a class="el" href="structPV__Stream__.html">PV_Stream</a> *pvstream, int k, int arborID)</td></tr>
<tr class="separator:a58761a72c9fce387f3751e483dfdfb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5dd9cf14ed977776b25eabd71ee388"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a7c5dd9cf14ed977776b25eabd71ee388">writeTimers</a> (FILE *stream)</td></tr>
<tr class="separator:a7c5dd9cf14ed977776b25eabd71ee388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c369deb20999871a93dcda8d44dee1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3c369deb20999871a93dcda8d44dee1"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>writeWeights</b> (double timed, bool last=false)</td></tr>
<tr class="separator:ac3c369deb20999871a93dcda8d44dee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac701d7b056bb895fe1da66c2c466b973"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac701d7b056bb895fe1da66c2c466b973"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>writeWeights</b> (const char *filename)</td></tr>
<tr class="separator:ac701d7b056bb895fe1da66c2c466b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf517993c87f170a3ba077bf68b7591"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbf517993c87f170a3ba077bf68b7591"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>writeWeights</b> (PVPatch ***patches, pvwdata_t **dataStart, int numPatches, const char *filename, double timef, bool compressWeights, bool last)</td></tr>
<tr class="separator:adbf517993c87f170a3ba077bf68b7591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdc102d87d8f4f37fdb3e85af49adb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bdc102d87d8f4f37fdb3e85af49adb2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>xPatchSize</b> ()</td></tr>
<tr class="separator:a8bdc102d87d8f4f37fdb3e85af49adb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d1f47cf215abf70889352605066f53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12d1f47cf215abf70889352605066f53"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>xPatchStride</b> ()</td></tr>
<tr class="separator:a12d1f47cf215abf70889352605066f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad917b77cf6d629a535c7d170af920263"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad917b77cf6d629a535c7d170af920263"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>xPostPatchSize</b> ()</td></tr>
<tr class="separator:ad917b77cf6d629a535c7d170af920263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0facd46a9017f5c7146ae0481f8fff5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0facd46a9017f5c7146ae0481f8fff5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>yPatchSize</b> ()</td></tr>
<tr class="separator:ad0facd46a9017f5c7146ae0481f8fff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad915034859b67b1026b8dfef4a6f5593"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad915034859b67b1026b8dfef4a6f5593"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>yPatchStride</b> ()</td></tr>
<tr class="separator:ad915034859b67b1026b8dfef4a6f5593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fe33e5f9230069293918234e316ae1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57fe33e5f9230069293918234e316ae1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>yPostPatchSize</b> ()</td></tr>
<tr class="separator:a57fe33e5f9230069293918234e316ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a96fc901eafe01de6b82d52e5db8833f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96fc901eafe01de6b82d52e5db8833f1"></a>
static PVPatch **&#160;</td><td class="memItemRight" valign="bottom"><b>createPatches</b> (int nPatches, int nx, int ny)</td></tr>
<tr class="separator:a96fc901eafe01de6b82d52e5db8833f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba107f973b3fa0d40065cb1ecddee4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acba107f973b3fa0d40065cb1ecddee4a"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>deletePatches</b> (PVPatch **patchpointers)</td></tr>
<tr class="separator:acba107f973b3fa0d40065cb1ecddee4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae836b72606165a12f71f7e972e7166ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae836b72606165a12f71f7e972e7166ff"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>pvpatch_adjust</b> (PVPatch *p, int sx, int sy, int nxNew, int nyNew, int dx, int dy)</td></tr>
<tr class="separator:ae836b72606165a12f71f7e972e7166ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4301595224020585f24074fbf09299"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea4301595224020585f24074fbf09299"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>pvpatch_init</b> (PVPatch *p, int nx, int ny)</td></tr>
<tr class="separator:aea4301595224020585f24074fbf09299"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:abe5d9f6ef7e36ff8aad52520805f6b36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe5d9f6ef7e36ff8aad52520805f6b36"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>accumulateFunctionFromPostPointer</b> )(int kPreRes, int nk, float *v, float *a, pvwdata_t *w, float dt_factor, void *auxPtr, int sf)</td></tr>
<tr class="separator:abe5d9f6ef7e36ff8aad52520805f6b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306580a5d1c336e43852c059dc562a5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a306580a5d1c336e43852c059dc562a5c"></a>
int(*&#160;</td><td class="memItemRight" valign="bottom"><b>accumulateFunctionPointer</b> )(int kPreRes, int nk, float *v, float a, pvwdata_t *w, void *auxPtr, int sf)</td></tr>
<tr class="separator:a306580a5d1c336e43852c059dc562a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac28a7e3c7bdae0320434d34b8efb2758"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac28a7e3c7bdae0320434d34b8efb2758"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>adjustAllPatches</b> (int nxPre, int nyPre, int nfPre, const <a class="el" href="structPVHalo__.html">PVHalo</a> *haloPre, int nxPost, int nyPost, int nfPost, const <a class="el" href="structPVHalo__.html">PVHalo</a> *haloPost, PVPatch ***inWPatches, size_t **inGSynPatchStart, size_t **inAPostOffset, int arborId)</td></tr>
<tr class="separator:ac28a7e3c7bdae0320434d34b8efb2758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026f6b068710cc1620e60c6dfdfd3c41"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a026f6b068710cc1620e60c6dfdfd3c41">adjustAxonalArbors</a> (int arborId)</td></tr>
<tr class="separator:a026f6b068710cc1620e60c6dfdfd3c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67cf553c459db1415a115d2edc39474"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af67cf553c459db1415a115d2edc39474"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>allocateDeviceBuffers</b> ()</td></tr>
<tr class="separator:af67cf553c459db1415a115d2edc39474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fa16ab5a88ba9745d3587a6725d7c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74fa16ab5a88ba9745d3587a6725d7c0"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>allocateDeviceWeights</b> ()</td></tr>
<tr class="separator:a74fa16ab5a88ba9745d3587a6725d7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b5675413e64ba23fe653958b5ce1f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38b5675413e64ba23fe653958b5ce1f6"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>allocatePostConn</b> ()</td></tr>
<tr class="separator:a38b5675413e64ba23fe653958b5ce1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95be5939cf43afbcecce01673dd415ab"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a95be5939cf43afbcecce01673dd415ab">allocatePostDeviceWeights</a> ()</td></tr>
<tr class="separator:a95be5939cf43afbcecce01673dd415ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf436d32a5071a9637936d0cd356ae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbf436d32a5071a9637936d0cd356ae7"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>allocatePreToPostBuffer</b> ()</td></tr>
<tr class="separator:abbf436d32a5071a9637936d0cd356ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1046d1359b1e1716399379c1423f50f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1046d1359b1e1716399379c1423f50f9"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>allocateReceivePostKernel</b> ()</td></tr>
<tr class="separator:a1046d1359b1e1716399379c1423f50f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71711d59c1978be5b9d28307034dfe6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71711d59c1978be5b9d28307034dfe6b"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>allocateReceivePreKernel</b> ()</td></tr>
<tr class="separator:a71711d59c1978be5b9d28307034dfe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0357875dca4be3f272adb26cb04cfe52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0357875dca4be3f272adb26cb04cfe52"></a>
virtual pvwdata_t *&#160;</td><td class="memItemRight" valign="bottom"><b>allocWeights</b> (int nPatches, int nxPatch, int nyPatch, int nfPatch)</td></tr>
<tr class="separator:a0357875dca4be3f272adb26cb04cfe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1ae7331e7f8ce3312b2139c7be4922"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e1ae7331e7f8ce3312b2139c7be4922"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>calc_dW</b> (int arborId=0)</td></tr>
<tr class="separator:a7e1ae7331e7f8ce3312b2139c7be4922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158a7cd2e2c0619eda6ac3b2a81b0540"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a158a7cd2e2c0619eda6ac3b2a81b0540"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>calcUnitCellIndex</b> (int patchIndex, int *kxUnitCellIndex=NULL, int *kyUnitCellIndex=NULL, int *kfUnitCellIndex=NULL)</td></tr>
<tr class="separator:a158a7cd2e2c0619eda6ac3b2a81b0540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fe8661131d8eb1de30bbaf7ee675d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11fe8661131d8eb1de30bbaf7ee675d1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>checkPatchDimensions</b> ()</td></tr>
<tr class="separator:a11fe8661131d8eb1de30bbaf7ee675d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c217a328d03daa9c589e38e758dea56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c217a328d03daa9c589e38e758dea56"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>checkPatchSize</b> (int patchSize, int scalePre, int scalePost, char dim)</td></tr>
<tr class="separator:a4c217a328d03daa9c589e38e758dea56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff4efba6978edafded504474109bf29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ff4efba6978edafded504474109bf29"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>checkpointFilename</b> (char *cpFilename, int size, const char *cpDir)</td></tr>
<tr class="separator:a3ff4efba6978edafded504474109bf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1ee32808602a7db1de24e1b47ae89a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb1ee32808602a7db1de24e1b47ae89a"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>clear_dW</b> ()</td></tr>
<tr class="separator:acb1ee32808602a7db1de24e1b47ae89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b418bf49de2876ca6aaf8812d83d8ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b418bf49de2876ca6aaf8812d83d8ff"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>clearWeights</b> (pvwdata_t **dataStart, int numPatches, int nx, int ny, int nf)</td></tr>
<tr class="separator:a0b418bf49de2876ca6aaf8812d83d8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27169175ae85c1e242d90f5b9116b7e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27169175ae85c1e242d90f5b9116b7e0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>connOutOfMemory</b> (const char *funcname)</td></tr>
<tr class="separator:a27169175ae85c1e242d90f5b9116b7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8abb42b81c1c54e296ba30b96a9b55b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#af8abb42b81c1c54e296ba30b96a9b55b">constructWeights</a> ()</td></tr>
<tr class="separator:af8abb42b81c1c54e296ba30b96a9b55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0757dca5b5a80573df5ea813cd4c0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d0757dca5b5a80573df5ea813cd4c0f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>createArbors</b> ()</td></tr>
<tr class="separator:a1d0757dca5b5a80573df5ea813cd4c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ad05e44c8d73f892040f3e55f23e82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0ad05e44c8d73f892040f3e55f23e82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>createArborsOutOfMemory</b> ()</td></tr>
<tr class="separator:ad0ad05e44c8d73f892040f3e55f23e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581192fde05732a0fa0c8869d6bec7e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a581192fde05732a0fa0c8869d6bec7e2"></a>
virtual <a class="el" href="classPV_1_1InitWeights.html">InitWeights</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createInitWeightsObject</b> (const char *weightInitTypeStr)</td></tr>
<tr class="separator:a581192fde05732a0fa0c8869d6bec7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf9bfd2127468e658735459b11bd282"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cf9bfd2127468e658735459b11bd282"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>createWeights</b> (PVPatch ***patches, int nWeightPatches, int nDataPatches, int nxPatch, int nyPatch, int nfPatch, int arborId)</td></tr>
<tr class="separator:a2cf9bfd2127468e658735459b11bd282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165c200843c9df6a98be0b17fe17d70c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a165c200843c9df6a98be0b17fe17d70c">createWeights</a> (PVPatch ***patches, int arborId)</td></tr>
<tr class="separator:a165c200843c9df6a98be0b17fe17d70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5e6483d28a8ed5152324f6e317ccdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a5e6483d28a8ed5152324f6e317ccdd"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>defaultUpdate_dW</b> (int arborId)</td></tr>
<tr class="separator:a3a5e6483d28a8ed5152324f6e317ccdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dd526adce32f2a371af4358449fe56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96dd526adce32f2a371af4358449fe56"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>deliverPostsynapticPerspective</b> (<a class="el" href="structPVLayerCube__.html">PVLayerCube</a> const *activity, int arborID)</td></tr>
<tr class="separator:a96dd526adce32f2a371af4358449fe56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9904c8d2c249f54eef93c4ea3e1c8fcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9904c8d2c249f54eef93c4ea3e1c8fcd"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>deliverPostsynapticPerspectiveGPU</b> (<a class="el" href="structPVLayerCube__.html">PVLayerCube</a> const *activity, int arborID)</td></tr>
<tr class="separator:a9904c8d2c249f54eef93c4ea3e1c8fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855eaeeb96c2784d3262a4d7ffc5b813"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a855eaeeb96c2784d3262a4d7ffc5b813"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>deliverPresynapticPerspective</b> (<a class="el" href="structPVLayerCube__.html">PVLayerCube</a> const *activity, int arborID)</td></tr>
<tr class="separator:a855eaeeb96c2784d3262a4d7ffc5b813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d43c7417fd1ea2bba2d5d12173363a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69d43c7417fd1ea2bba2d5d12173363a"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>deliverPresynapticPerspectiveGPU</b> (<a class="el" href="structPVLayerCube__.html">PVLayerCube</a> const *activity, int arborID)</td></tr>
<tr class="separator:a69d43c7417fd1ea2bba2d5d12173363a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44de18be7402d6d73bc06031799096b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab44de18be7402d6d73bc06031799096b"></a>
pvwdata_t **&#160;</td><td class="memItemRight" valign="bottom"><b>get_dwDataStart</b> ()</td></tr>
<tr class="separator:ab44de18be7402d6d73bc06031799096b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f33963c7c757a52e2f9cef3c37e774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0f33963c7c757a52e2f9cef3c37e774"></a>
pvwdata_t **&#160;</td><td class="memItemRight" valign="bottom"><b>get_wDataStart</b> ()</td></tr>
<tr class="separator:ab0f33963c7c757a52e2f9cef3c37e774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4aa155c5a1a46c68a84bdcf2125f44a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4aa155c5a1a46c68a84bdcf2125f44a"></a>
PVPatch ***&#160;</td><td class="memItemRight" valign="bottom"><b>get_wPatches</b> ()</td></tr>
<tr class="separator:ae4aa155c5a1a46c68a84bdcf2125f44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa535a5c5b4e14374c82361b794e9f714"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa535a5c5b4e14374c82361b794e9f714"></a>
size_t **&#160;</td><td class="memItemRight" valign="bottom"><b>getAPostOffset</b> ()</td></tr>
<tr class="separator:aa535a5c5b4e14374c82361b794e9f714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c948b1ef2a28bd8bdb6d3ccc1bcb75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47c948b1ef2a28bd8bdb6d3ccc1bcb75"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>getConvertToRateDeltaTimeFactor</b> ()</td></tr>
<tr class="separator:a47c948b1ef2a28bd8bdb6d3ccc1bcb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b655db50a79f14fc86bcf6edca27aae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b655db50a79f14fc86bcf6edca27aae"></a>
virtual <a class="el" href="classPV_1_1InitWeights.html">InitWeights</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultInitWeightsMethod</b> (const char *keyword)</td></tr>
<tr class="separator:a5b655db50a79f14fc86bcf6edca27aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6655f465c3758ccf16762bb29c3924f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a6655f465c3758ccf16762bb29c3924f7">getPreAndPostLayerNames</a> (const char *name, <a class="el" href="classPV_1_1PVParams.html">PVParams</a> *params, char **preLayerNamePtr, char **postLayerNamePtr)</td></tr>
<tr class="separator:a6655f465c3758ccf16762bb29c3924f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c956c7f1c7bbb3f1984fdfe798289ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c956c7f1c7bbb3f1984fdfe798289ea"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>handleDefaultSelfFlag</b> ()</td></tr>
<tr class="separator:a2c956c7f1c7bbb3f1984fdfe798289ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af288d6023bba10bc335703cd63d4e8ff"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#af288d6023bba10bc335703cd63d4e8ff">handleMissingPreAndPostLayerNames</a> ()</td></tr>
<tr class="separator:af288d6023bba10bc335703cd63d4e8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae7beeb7c502f2518c7d43c3289d395"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae7beeb7c502f2518c7d43c3289d395"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>imprintFeature</b> (int arborId, int kExt)</td></tr>
<tr class="separator:aaae7beeb7c502f2518c7d43c3289d395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a439c2eda66dea4c83fb42135e383e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ac9a439c2eda66dea4c83fb42135e383e">initialize</a> (const char *name, <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *hc)</td></tr>
<tr class="separator:ac9a439c2eda66dea4c83fb42135e383e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6b78ec17d91f421a2efd03d78541bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa6b78ec17d91f421a2efd03d78541bf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>initialize</b> (const char *name, <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *hc, <a class="el" href="classPV_1_1InitWeights.html">InitWeights</a> *weightInitializer, <a class="el" href="classPV_1_1NormalizeBase.html">NormalizeBase</a> *weightNormalizer)</td></tr>
<tr class="separator:aaa6b78ec17d91f421a2efd03d78541bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf37a7abd8b9dc01d077e2f61d429890"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf37a7abd8b9dc01d077e2f61d429890"></a>
virtual PVPatch ***&#160;</td><td class="memItemRight" valign="bottom"><b>initializeWeights</b> (PVPatch ***arbors, pvwdata_t **dataStart)</td></tr>
<tr class="separator:aaf37a7abd8b9dc01d077e2f61d429890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553d5409a38e1460fc978e20da32ecc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a553d5409a38e1460fc978e20da32ecc6"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>initNumDataPatches</b> ()</td></tr>
<tr class="separator:a553d5409a38e1460fc978e20da32ecc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae882c206e04446da83f7e4e296b8d294"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae882c206e04446da83f7e4e296b8d294"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>initNumWeightPatches</b> ()</td></tr>
<tr class="separator:ae882c206e04446da83f7e4e296b8d294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d15490ccccf12abcdfa90c0e63443e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4d15490ccccf12abcdfa90c0e63443e"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>initPlasticityPatches</b> ()</td></tr>
<tr class="separator:aa4d15490ccccf12abcdfa90c0e63443e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2fc25b665914a819f89a8e3e3d3bc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a2fc25b665914a819f89a8e3e3d3bc8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>ioParam_imprintTimeThresh</b> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="separator:a8a2fc25b665914a819f89a8e3e3d3bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3636e6a8e78bca71e6c1480adf866692"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3636e6a8e78bca71e6c1480adf866692"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1ImprintConn.html#a3636e6a8e78bca71e6c1480adf866692">ioParam_sharedWeights</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a3636e6a8e78bca71e6c1480adf866692"><td class="mdescLeft">&#160;</td><td class="mdescRight">sharedWeights: Defines if the <a class="el" href="classPV_1_1HyPerConn.html">HyPerConn</a> uses shared weights (kernelConn) <br /></td></tr>
<tr class="separator:a3636e6a8e78bca71e6c1480adf866692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab1db3a961dab411b23c233e8d6aa86"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1ImprintConn.html#a9ab1db3a961dab411b23c233e8d6aa86">ioParamsFillGroup</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="separator:a9ab1db3a961dab411b23c233e8d6aa86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34518ae81af452b840e5dcde0c94c6c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34518ae81af452b840e5dcde0c94c6c5"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_dW</b> (int arbor_ID)</td></tr>
<tr class="separator:a34518ae81af452b840e5dcde0c94c6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77eb5e713f08e1c801c976fe0477febe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77eb5e713f08e1c801c976fe0477febe"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>patchStartIndex</b> (int patchIndex)</td></tr>
<tr class="separator:a77eb5e713f08e1c801c976fe0477febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d8e2d6f2c2ae4731097338735dc49e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87d8e2d6f2c2ae4731097338735dc49e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>postPatchStartIndex</b> (int patchIndex)</td></tr>
<tr class="separator:a87d8e2d6f2c2ae4731097338735dc49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5672b85261f505ab757e8c54ffc1bef1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a5672b85261f505ab757e8c54ffc1bef1">readStateFromCheckpoint</a> (const char *cpDir, double *timeptr)</td></tr>
<tr class="separator:a5672b85261f505ab757e8c54ffc1bef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12be7bc9add57ec9b4de7e4b85c20115"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12be7bc9add57ec9b4de7e4b85c20115"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>readWeightsFromCheckpoint</b> (const char *cpDir, double *timeptr)</td></tr>
<tr class="separator:a12be7bc9add57ec9b4de7e4b85c20115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf0c1f1d1c2b415fcf2227d8b9293f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bf0c1f1d1c2b415fcf2227d8b9293f4"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>reduceKernels</b> (int arborID)</td></tr>
<tr class="separator:a7bf0c1f1d1c2b415fcf2227d8b9293f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf53ba564c8eb15b192f87011cdcf3dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf53ba564c8eb15b192f87011cdcf3dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_dwDataStart</b> (pvwdata_t **datastart)</td></tr>
<tr class="separator:aaf53ba564c8eb15b192f87011cdcf3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6279dfc8243e1d584c3b10db42e449"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed6279dfc8243e1d584c3b10db42e449"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_dwDataStart</b> (int arborId, pvwdata_t *pIncrStart)</td></tr>
<tr class="separator:aed6279dfc8243e1d584c3b10db42e449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e2d8e5b4da91d520b1492efa46f2f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98e2d8e5b4da91d520b1492efa46f2f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_wDataStart</b> (pvwdata_t **datastart)</td></tr>
<tr class="separator:a98e2d8e5b4da91d520b1492efa46f2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8402f5aedd105031a3a524dbf713f7f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8402f5aedd105031a3a524dbf713f7f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_wDataStart</b> (int arborId, pvwdata_t *pDataStart)</td></tr>
<tr class="separator:a8402f5aedd105031a3a524dbf713f7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b14d10588d156eb91c0843507473627"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b14d10588d156eb91c0843507473627"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_wPatches</b> (PVPatch ***patches)</td></tr>
<tr class="separator:a5b14d10588d156eb91c0843507473627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58701681c15420ef1e2f00c55d37ce67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58701681c15420ef1e2f00c55d37ce67"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setAPostOffset</b> (size_t **postoffset)</td></tr>
<tr class="separator:a58701681c15420ef1e2f00c55d37ce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fd61a0b40955bb2cb4b5292372a7e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a88fd61a0b40955bb2cb4b5292372a7e8">setChannelType</a> (ChannelType ch)</td></tr>
<tr class="separator:a88fd61a0b40955bb2cb4b5292372a7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16596840aabceadcca9eeeb5509bb1a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a16596840aabceadcca9eeeb5509bb1a2">setConvertRateToSpikeCount</a> (bool convertRateToSpikeCountFlag)</td></tr>
<tr class="separator:a16596840aabceadcca9eeeb5509bb1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383eb2713c08082509f74639ee2f8898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a383eb2713c08082509f74639ee2f8898">setDelay</a> (int arborId, float delay)</td></tr>
<tr class="separator:a383eb2713c08082509f74639ee2f8898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb117c443819196ade22dfeb21429c3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb117c443819196ade22dfeb21429c3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setGSynPatchStart</b> (size_t **patchstart)</td></tr>
<tr class="separator:aeb117c443819196ade22dfeb21429c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7131cc61ed6ee2101feb720f271a01b8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a7131cc61ed6ee2101feb720f271a01b8">setInitialValues</a> ()</td></tr>
<tr class="separator:a7131cc61ed6ee2101feb720f271a01b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605ab0c6f896a76244f1775551a7dc7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a605ab0c6f896a76244f1775551a7dc7e">setName</a> (const char *name)</td></tr>
<tr class="separator:a605ab0c6f896a76244f1775551a7dc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6be4f8f8e3001a80d63d67a11f5f95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a4f6be4f8f8e3001a80d63d67a11f5f95">setNumberOfAxonalArborLists</a> (int numArbors)</td></tr>
<tr class="separator:a4f6be4f8f8e3001a80d63d67a11f5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d0597598512a94bde243a303997dce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a50d0597598512a94bde243a303997dce">setParent</a> (<a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *hc)</td></tr>
<tr class="separator:a50d0597598512a94bde243a303997dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec44c32735726f920900a4d7bbcbd58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ec44c32735726f920900a4d7bbcbd58"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>setPatchSize</b> ()</td></tr>
<tr class="separator:a7ec44c32735726f920900a4d7bbcbd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7742c6574ade1b7abd690a04c182558c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7742c6574ade1b7abd690a04c182558c"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>setPatchStrides</b> ()</td></tr>
<tr class="separator:a7742c6574ade1b7abd690a04c182558c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d797c65e886cf495d092d52b2f02367"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d797c65e886cf495d092d52b2f02367"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>setPostLayerName</b> (const char *post_name)</td></tr>
<tr class="separator:a6d797c65e886cf495d092d52b2f02367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35d35a5b6102d43cc7e32ad3e1d534d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab35d35a5b6102d43cc7e32ad3e1d534d"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>setPostPatchSize</b> ()</td></tr>
<tr class="separator:ab35d35a5b6102d43cc7e32ad3e1d534d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdd51256f17d3c3d3e126d38eec5c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#abfdd51256f17d3c3d3e126d38eec5c43">setPostSynapticLayer</a> (<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *post)</td></tr>
<tr class="separator:abfdd51256f17d3c3d3e126d38eec5c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305b16e794769ffa39e2e5557025c7c3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a305b16e794769ffa39e2e5557025c7c3">setPreAndPostLayerNames</a> ()</td></tr>
<tr class="separator:a305b16e794769ffa39e2e5557025c7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442f61c0c59c14706cdda022734e4663"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a442f61c0c59c14706cdda022734e4663"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>setPreLayerName</b> (const char *pre_name)</td></tr>
<tr class="separator:a442f61c0c59c14706cdda022734e4663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ac6677b9533df9fbc991a5788de1c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ac9ac6677b9533df9fbc991a5788de1c1">setPreSynapticLayer</a> (<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *pre)</td></tr>
<tr class="separator:ac9ac6677b9533df9fbc991a5788de1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b67261072e5e282f54ac1e5785fa8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84b67261072e5e282f54ac1e5785fa8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setReceiveGpu</b> ()</td></tr>
<tr class="separator:a84b67261072e5e282f54ac1e5785fa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5040ad0eb669d13e7d67f53d07f289f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5040ad0eb669d13e7d67f53d07f289f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>setWeightInitializer</b> ()</td></tr>
<tr class="separator:ab5040ad0eb669d13e7d67f53d07f289f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067b7dbdc7592a641b4220dd4d7335fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a067b7dbdc7592a641b4220dd4d7335fe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>setWeightNormalizer</b> ()</td></tr>
<tr class="separator:a067b7dbdc7592a641b4220dd4d7335fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13791a899e69e3c47927c0ed25b238d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13791a899e69e3c47927c0ed25b238d1"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>skipPre</b> (pvdata_t preact)</td></tr>
<tr class="separator:a13791a899e69e3c47927c0ed25b238d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1fcef52d952353657483114db99aae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b1fcef52d952353657483114db99aae"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateDeviceWeights</b> ()</td></tr>
<tr class="separator:a5b1fcef52d952353657483114db99aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb796940a5b9ff88eba200a8889d29b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceb796940a5b9ff88eba200a8889d29b"></a>
virtual pvdata_t&#160;</td><td class="memItemRight" valign="bottom"><b>updateRule_dW</b> (pvdata_t pre, pvdata_t post)</td></tr>
<tr class="separator:aceb796940a5b9ff88eba200a8889d29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a2e5d33843da268e5be4f4375cd752e55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e5d33843da268e5be4f4375cd752e55"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>adjustedPatchDimension</b> (int zPre, int preNeuronsPerPostNeuron, int postNeuronsPerPreNeuron, int nPost, int patchDim, int *postStartPtr, int *patchStartPtr, int *adjustedDim)</td></tr>
<tr class="separator:a2e5d33843da268e5be4f4375cd752e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d0fa15f08288eaa1494c51ce727c1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55d0fa15f08288eaa1494c51ce727c1f"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>computeMargin</b> (int prescale, int postscale, int patchsize)</td></tr>
<tr class="separator:a55d0fa15f08288eaa1494c51ce727c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca788ce4dea591c69b75e48097ce611"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#afca788ce4dea591c69b75e48097ce611">inferPreAndPostFromConnName</a> (const char *name, int rank, char **preLayerNamePtr, char **postLayerNamePtr)</td></tr>
<tr class="separator:afca788ce4dea591c69b75e48097ce611"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8ff709063a5d812c8f3086ed44e8e28a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ff709063a5d812c8f3086ed44e8e28a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>allocDeviceWeights</b></td></tr>
<tr class="separator:a8ff709063a5d812c8f3086ed44e8e28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c135ddfb2171bc224025f0ad2b7e4ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c135ddfb2171bc224025f0ad2b7e4ae"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>allocPostDeviceWeights</b></td></tr>
<tr class="separator:a3c135ddfb2171bc224025f0ad2b7e4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f2ca068c5a5d817d0a4b17c0286f4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67f2ca068c5a5d817d0a4b17c0286f4a"></a>
std::vector&lt; <a class="el" href="classPV_1_1PlasticCloneConn.html">PlasticCloneConn</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>clones</b></td></tr>
<tr class="separator:a67f2ca068c5a5d817d0a4b17c0286f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7073cb5a8d33ed052750b79c668bf2f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7073cb5a8d33ed052750b79c668bf2f1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>combine_dW_with_W_flag</b></td></tr>
<tr class="separator:a7073cb5a8d33ed052750b79c668bf2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69abb33059c9640cb4c9aa7886f71c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab69abb33059c9640cb4c9aa7886f71c2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>combineWeightFiles</b></td></tr>
<tr class="separator:ab69abb33059c9640cb4c9aa7886f71c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4592095fed01203283eedb334b77e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc4592095fed01203283eedb334b77e6"></a>
PVCuda::CudaBuffer *&#160;</td><td class="memItemRight" valign="bottom"><b>d_GSynPatchStart</b></td></tr>
<tr class="separator:adc4592095fed01203283eedb334b77e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311e4554e4af6ff9ee7500c035406e12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a311e4554e4af6ff9ee7500c035406e12"></a>
PVCuda::CudaBuffer *&#160;</td><td class="memItemRight" valign="bottom"><b>d_Patch2DataLookupTable</b></td></tr>
<tr class="separator:a311e4554e4af6ff9ee7500c035406e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755304d6f2b4cc44d57e51ce43dc23ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a755304d6f2b4cc44d57e51ce43dc23ed"></a>
PVCuda::CudaBuffer *&#160;</td><td class="memItemRight" valign="bottom"><b>d_Patches</b></td></tr>
<tr class="separator:a755304d6f2b4cc44d57e51ce43dc23ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196e8009575e84c12c8b37c270508863"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a196e8009575e84c12c8b37c270508863"></a>
PVCuda::CudaBuffer *&#160;</td><td class="memItemRight" valign="bottom"><b>d_PostToPreActivity</b></td></tr>
<tr class="separator:a196e8009575e84c12c8b37c270508863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0584ae48ce246eab856f4dff95d260f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0584ae48ce246eab856f4dff95d260f5"></a>
PVCuda::CudaBuffer *&#160;</td><td class="memItemRight" valign="bottom"><b>d_WData</b></td></tr>
<tr class="separator:a0584ae48ce246eab856f4dff95d260f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f215cb5baa0fcc2b475bb83dbd3da5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f215cb5baa0fcc2b475bb83dbd3da5c"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>dWMax</b></td></tr>
<tr class="separator:a0f215cb5baa0fcc2b475bb83dbd3da5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc3dc83572d7041ab7081061029bf51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfc3dc83572d7041ab7081061029bf51"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fileparams</b> [NUM_WGT_PARAMS]</td></tr>
<tr class="separator:adfc3dc83572d7041ab7081061029bf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03544689598bd4608e02daf1c51a6bae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03544689598bd4608e02daf1c51a6bae"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fileType</b></td></tr>
<tr class="separator:a03544689598bd4608e02daf1c51a6bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53741671b68229c6b7c631e10e4432b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab53741671b68229c6b7c631e10e4432b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>gpuGroupIdx</b></td></tr>
<tr class="separator:ab53741671b68229c6b7c631e10e4432b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b32cf4c67adfbfebd5c90c8814cc25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3b32cf4c67adfbfebd5c90c8814cc25"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>imprintTimeThresh</b></td></tr>
<tr class="separator:ac3b32cf4c67adfbfebd5c90c8814cc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b12cedea094759e143a60b04e5daa4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b12cedea094759e143a60b04e5daa4f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>initialWeightUpdateTime</b></td></tr>
<tr class="separator:a0b12cedea094759e143a60b04e5daa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e010d3b3dc0a5313df0100a59a54ce7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e010d3b3dc0a5313df0100a59a54ce7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>initialWriteTime</b></td></tr>
<tr class="separator:a2e010d3b3dc0a5313df0100a59a54ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461fe10967a846814bef4370bb04a5e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a461fe10967a846814bef4370bb04a5e4"></a>
<a class="el" href="classPV_1_1Timer.html">Timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>io_timer</b></td></tr>
<tr class="separator:a461fe10967a846814bef4370bb04a5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac551fb24631b6517a1cfa63819a605c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac551fb24631b6517a1cfa63819a605c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ioAppend</b></td></tr>
<tr class="separator:aac551fb24631b6517a1cfa63819a605c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944721c2b09fc568f97d4727d0f2df2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a944721c2b09fc568f97d4727d0f2df2c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>keepKernelsSynchronized_flag</b></td></tr>
<tr class="separator:a944721c2b09fc568f97d4727d0f2df2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d77dfd6c7f96d3253f358dfdc67f9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72d77dfd6c7f96d3253f358dfdc67f9b"></a>
<a class="el" href="classPVCuda_1_1CudaRecvPost.html">PVCuda::CudaRecvPost</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>krRecvPost</b></td></tr>
<tr class="separator:a72d77dfd6c7f96d3253f358dfdc67f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8148d9eccc1e93844a3e9c8fd3fce86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8148d9eccc1e93844a3e9c8fd3fce86"></a>
<a class="el" href="classPVCuda_1_1CudaRecvPre.html">PVCuda::CudaRecvPre</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>krRecvPre</b></td></tr>
<tr class="separator:ab8148d9eccc1e93844a3e9c8fd3fce86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32de097a45474086bace72de40878bc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32de097a45474086bace72de40878bc1"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>lastActiveTime</b></td></tr>
<tr class="separator:a32de097a45474086bace72de40878bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9520cfdcff15b89ca1b0625db9ece302"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9520cfdcff15b89ca1b0625db9ece302"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>lastUpdateTime</b></td></tr>
<tr class="separator:a9520cfdcff15b89ca1b0625db9ece302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f802a768f96581406ca8664b89b9e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11f802a768f96581406ca8664b89b9e5"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mask</b></td></tr>
<tr class="separator:a11f802a768f96581406ca8664b89b9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6ada662d9aa62d8d3563d01d25c6d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f6ada662d9aa62d8d3563d01d25c6d1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>maskFeatureIdx</b></td></tr>
<tr class="separator:a6f6ada662d9aa62d8d3563d01d25c6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1114e688cf0c5bda7396db86f08408c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1114e688cf0c5bda7396db86f08408c7"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>maskLayerName</b></td></tr>
<tr class="separator:a1114e688cf0c5bda7396db86f08408c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0156d139c46b0b34bd2e0805408358"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f0156d139c46b0b34bd2e0805408358"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>needAllocPostWeights</b></td></tr>
<tr class="separator:a8f0156d139c46b0b34bd2e0805408358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c2f7c20fdc51f4f389f7473835fc43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39c2f7c20fdc51f4f389f7473835fc43"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>needFinalize</b></td></tr>
<tr class="separator:a39c2f7c20fdc51f4f389f7473835fc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d899cc11f996c0dd0661623a1f8987"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88d899cc11f996c0dd0661623a1f8987"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nfp</b></td></tr>
<tr class="separator:a88d899cc11f996c0dd0661623a1f8987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7984b4cdb55f6f5b798f608bb2225e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7984b4cdb55f6f5b798f608bb2225e0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nfpPost</b></td></tr>
<tr class="separator:ad7984b4cdb55f6f5b798f608bb2225e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2e60dd7e16b9a8bb77581de2d7f010"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d2e60dd7e16b9a8bb77581de2d7f010"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_cutoff</b></td></tr>
<tr class="separator:a6d2e60dd7e16b9a8bb77581de2d7f010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5d5202126bad946f781878ea17bc21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d5d5202126bad946f781878ea17bc21"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_max</b></td></tr>
<tr class="separator:a4d5d5202126bad946f781878ea17bc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566618a482b797045abee023f22e4e16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a566618a482b797045abee023f22e4e16"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_RMS_amp</b></td></tr>
<tr class="separator:a566618a482b797045abee023f22e4e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bef9da5b0026c00f2cd3ce48b1db52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69bef9da5b0026c00f2cd3ce48b1db52"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_strength</b></td></tr>
<tr class="separator:a69bef9da5b0026c00f2cd3ce48b1db52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9d3ecc1da02339e917c3b40eefc8a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add9d3ecc1da02339e917c3b40eefc8a6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_zero_offset</b></td></tr>
<tr class="separator:add9d3ecc1da02339e917c3b40eefc8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81047c940d74fee5652ed0aa37af57ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81047c940d74fee5652ed0aa37af57ef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>normalizeArborsIndividually</b></td></tr>
<tr class="separator:a81047c940d74fee5652ed0aa37af57ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc9ba09ae78955411fb4a1b58ca9480"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbc9ba09ae78955411fb4a1b58ca9480"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>normalizeGroupName</b></td></tr>
<tr class="separator:abbc9ba09ae78955411fb4a1b58ca9480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5a6812fe42fcdea10200bbd143a1ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e5a6812fe42fcdea10200bbd143a1ee"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>normalizeMethod</b></td></tr>
<tr class="separator:a2e5a6812fe42fcdea10200bbd143a1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b09186d6080bb1f9b88275ebff31b24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b09186d6080bb1f9b88275ebff31b24"></a>
<a class="el" href="classPV_1_1NormalizeBase.html">NormalizeBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>normalizer</b></td></tr>
<tr class="separator:a2b09186d6080bb1f9b88275ebff31b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c556992c161450c14b489ad10b91a53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c556992c161450c14b489ad10b91a53"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>normalizeTotalToPost</b></td></tr>
<tr class="separator:a6c556992c161450c14b489ad10b91a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021492a9771e5fee18cdc0e2ee60edaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a021492a9771e5fee18cdc0e2ee60edaa"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numDataPatches</b></td></tr>
<tr class="separator:a021492a9771e5fee18cdc0e2ee60edaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41897f1fa1b61d2689413215d17bdc27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41897f1fa1b61d2689413215d17bdc27"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numFLocal</b></td></tr>
<tr class="separator:a41897f1fa1b61d2689413215d17bdc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12142b33a030f848aef03e86bb4463d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae12142b33a030f848aef03e86bb4463d"></a>
long ***&#160;</td><td class="memItemRight" valign="bottom"><b>numKernelActivations</b></td></tr>
<tr class="separator:ae12142b33a030f848aef03e86bb4463d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b0efa46aca6d596c1581a4f1e46d10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3b0efa46aca6d596c1581a4f1e46d10"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numParams</b></td></tr>
<tr class="separator:ac3b0efa46aca6d596c1581a4f1e46d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c399713d5a79a9aab0c1786ef808b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36c399713d5a79a9aab0c1786ef808b0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numWeightPatches</b></td></tr>
<tr class="separator:a36c399713d5a79a9aab0c1786ef808b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b065b6d86d8f82237009e09a9fdc36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24b065b6d86d8f82237009e09a9fdc36"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numXLocal</b></td></tr>
<tr class="separator:a24b065b6d86d8f82237009e09a9fdc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085e0c32e6d4e4c072fed5557feadf02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a085e0c32e6d4e4c072fed5557feadf02"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numYLocal</b></td></tr>
<tr class="separator:a085e0c32e6d4e4c072fed5557feadf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af844ee9a2612d4e40b55f84b489a35f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af844ee9a2612d4e40b55f84b489a35f7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nxp</b></td></tr>
<tr class="separator:af844ee9a2612d4e40b55f84b489a35f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae788b53c064b2a9828561ac3139eed32"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae788b53c064b2a9828561ac3139eed32"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nxpPost</b></td></tr>
<tr class="separator:ae788b53c064b2a9828561ac3139eed32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cc9faa49d0761f268f80538be716c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88cc9faa49d0761f268f80538be716c7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nyp</b></td></tr>
<tr class="separator:a88cc9faa49d0761f268f80538be716c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffc5df73a5b30cc093cd44cca3607c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ffc5df73a5b30cc093cd44cca3607c9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>nypPost</b></td></tr>
<tr class="separator:a9ffc5df73a5b30cc093cd44cca3607c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70f244224bbd8867d74b194c928633a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac70f244224bbd8867d74b194c928633a"></a>
<a class="el" href="classPV_1_1HyPerConn.html">HyPerConn</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>postConn</b></td></tr>
<tr class="separator:ac70f244224bbd8867d74b194c928633a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c09fabd0696925f1fbc9f3d8ed11e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93c09fabd0696925f1fbc9f3d8ed11e4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>preDataLocal</b></td></tr>
<tr class="separator:a93c09fabd0696925f1fbc9f3d8ed11e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2701a811b3dac437b58c5b343b8f5cfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2701a811b3dac437b58c5b343b8f5cfb"></a>
GSynAccumulateType&#160;</td><td class="memItemRight" valign="bottom"><b>pvpatchAccumulateType</b></td></tr>
<tr class="separator:a2701a811b3dac437b58c5b343b8f5cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6809e7b4658b797e0be0306c309555d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6809e7b4658b797e0be0306c309555d7"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>pvpatchAccumulateTypeString</b></td></tr>
<tr class="separator:a6809e7b4658b797e0be0306c309555d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29452784ab583b7b0922e5cd7ae3a1a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29452784ab583b7b0922e5cd7ae3a1a5"></a>
<a class="el" href="classPV_1_1Random.html">Random</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>randState</b></td></tr>
<tr class="separator:a29452784ab583b7b0922e5cd7ae3a1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1e48c2ca983da873267f0691e4b71d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe1e48c2ca983da873267f0691e4b71d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>selfFlag</b></td></tr>
<tr class="separator:afe1e48c2ca983da873267f0691e4b71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e5a228c188675cf69fbec17844b470"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43e5a228c188675cf69fbec17844b470"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sfp</b></td></tr>
<tr class="separator:a43e5a228c188675cf69fbec17844b470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64cb4fb64b6c8e0999dd796ae95fd18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af64cb4fb64b6c8e0999dd796ae95fd18"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sharedWeights</b></td></tr>
<tr class="separator:af64cb4fb64b6c8e0999dd796ae95fd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98709e7e796672bfa8d222ac2edd485a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98709e7e796672bfa8d222ac2edd485a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>shrinkPatches_flag</b></td></tr>
<tr class="separator:a98709e7e796672bfa8d222ac2edd485a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87dd99a3fbf96401155ff68ceb36710"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae87dd99a3fbf96401155ff68ceb36710"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>shrinkPatchesThresh</b></td></tr>
<tr class="separator:ae87dd99a3fbf96401155ff68ceb36710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d246349bcfd3f5188c75b8827541878"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d246349bcfd3f5188c75b8827541878"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sxp</b></td></tr>
<tr class="separator:a8d246349bcfd3f5188c75b8827541878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa978ca696e493da872116e03f36e2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fa978ca696e493da872116e03f36e2d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>symmetrizeWeightsFlag</b></td></tr>
<tr class="separator:a7fa978ca696e493da872116e03f36e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac377a44cf87c137abac1be82bf7cf265"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac377a44cf87c137abac1be82bf7cf265"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>syp</b></td></tr>
<tr class="separator:ac377a44cf87c137abac1be82bf7cf265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bb0ebc02df448ca43489fe6b96f7cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76bb0ebc02df448ca43489fe6b96f7cf"></a>
pvdata_t **&#160;</td><td class="memItemRight" valign="bottom"><b>thread_gSyn</b></td></tr>
<tr class="separator:a76bb0ebc02df448ca43489fe6b96f7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf34cd8647a5eae84135b5d8a15e7ff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf34cd8647a5eae84135b5d8a15e7ff7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>triggerFlag</b></td></tr>
<tr class="separator:abf34cd8647a5eae84135b5d8a15e7ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dd03ffa594fbbef3ef97748886be9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5dd03ffa594fbbef3ef97748886be9e"></a>
<a class="el" href="classPV_1_1Timer.html">Timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>update_timer</b></td></tr>
<tr class="separator:ae5dd03ffa594fbbef3ef97748886be9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbebbeb8e8b7471364e624e76d5bcb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fbebbeb8e8b7471364e624e76d5bcb0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>updateGSynFromPostPerspective</b></td></tr>
<tr class="separator:a2fbebbeb8e8b7471364e624e76d5bcb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b542b791ae1a7b3b4a518483862900"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5b542b791ae1a7b3b4a518483862900"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>useListOfArborFiles</b></td></tr>
<tr class="separator:af5b542b791ae1a7b3b4a518483862900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1427c3ccf975c9c2721996f62bd7dab6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1427c3ccf975c9c2721996f62bd7dab6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>useMask</b></td></tr>
<tr class="separator:a1427c3ccf975c9c2721996f62bd7dab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d540b296c7521896d00cd99240843"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a196d540b296c7521896d00cd99240843"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>warnDefaultNfp</b></td></tr>
<tr class="separator:a196d540b296c7521896d00cd99240843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5044666c01baa6eda66b576e5235eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a5044666c01baa6eda66b576e5235eb"></a>
<a class="el" href="classPV_1_1InitWeights.html">InitWeights</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>weightInitializer</b></td></tr>
<tr class="separator:a9a5044666c01baa6eda66b576e5235eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace64d83b693a5136e4dfe091e0c50049"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace64d83b693a5136e4dfe091e0c50049"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>weightInitTypeString</b></td></tr>
<tr class="separator:ace64d83b693a5136e4dfe091e0c50049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827cb3830d4342a9db6221ec7411c2c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a827cb3830d4342a9db6221ec7411c2c9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>weightUpdatePeriod</b></td></tr>
<tr class="separator:a827cb3830d4342a9db6221ec7411c2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234a25ad5e88a80badd1d583aae4c8a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a234a25ad5e88a80badd1d583aae4c8a7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>weightUpdateTime</b></td></tr>
<tr class="separator:a234a25ad5e88a80badd1d583aae4c8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e428f4996d15b6914fd16b05c84e19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2e428f4996d15b6914fd16b05c84e19"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>wMax</b></td></tr>
<tr class="separator:ad2e428f4996d15b6914fd16b05c84e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a01d41bff87919254146265e6f4cb4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a01d41bff87919254146265e6f4cb4d"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>wMin</b></td></tr>
<tr class="separator:a2a01d41bff87919254146265e6f4cb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e39e58f356b9172319d59a53ad0a13b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e39e58f356b9172319d59a53ad0a13b"></a>
pvwdata_t **&#160;</td><td class="memItemRight" valign="bottom"><b>wPostDataStart</b></td></tr>
<tr class="separator:a1e39e58f356b9172319d59a53ad0a13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad234e3bc998247e11671440c9fe62e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad234e3bc998247e11671440c9fe62e2"></a>
pvwdata_t ***&#160;</td><td class="memItemRight" valign="bottom"><b>wPostDataStartp</b></td></tr>
<tr class="separator:aad234e3bc998247e11671440c9fe62e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19f3c4efd52fb197435c78c6850b244"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa19f3c4efd52fb197435c78c6850b244"></a>
PVPatch ***&#160;</td><td class="memItemRight" valign="bottom"><b>wPostPatches</b></td></tr>
<tr class="separator:aa19f3c4efd52fb197435c78c6850b244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b761b90170fed325c637cbc7bf5cd48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b761b90170fed325c637cbc7bf5cd48"></a>
PVPatch ****&#160;</td><td class="memItemRight" valign="bottom"><b>wPostPatchesp</b></td></tr>
<tr class="separator:a9b761b90170fed325c637cbc7bf5cd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e68a8cf6a866e2b363b24f91792bd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9e68a8cf6a866e2b363b24f91792bd0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>wPostTime</b></td></tr>
<tr class="separator:aa9e68a8cf6a866e2b363b24f91792bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f00bb0e550241989c0c8fcd711d232"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38f00bb0e550241989c0c8fcd711d232"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>writeCompressedCheckpoints</b></td></tr>
<tr class="separator:a38f00bb0e550241989c0c8fcd711d232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7564fb5bb5064c245daa0074144109"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b7564fb5bb5064c245daa0074144109"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>writeCompressedWeights</b></td></tr>
<tr class="separator:a3b7564fb5bb5064c245daa0074144109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ba10197e5acaf37889b58387751316"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84ba10197e5acaf37889b58387751316"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>writeStep</b></td></tr>
<tr class="separator:a84ba10197e5acaf37889b58387751316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6beb94c07be8e85d9b1535ebe09c8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb6beb94c07be8e85d9b1535ebe09c8a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>writeTime</b></td></tr>
<tr class="separator:aeb6beb94c07be8e85d9b1535ebe09c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1c76216aeea11b66bb8cee0ada851dd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c76216aeea11b66bb8cee0ada851dd5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>initialize_base</b> ()</td></tr>
<tr class="separator:a1c76216aeea11b66bb8cee0ada851dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3f6bc1b8d31b9285fd51d12ff99d679e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f6bc1b8d31b9285fd51d12ff99d679e"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>imprintChance</b></td></tr>
<tr class="separator:a3f6bc1b8d31b9285fd51d12ff99d679e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6240195e142f0749829f0eb1858bd2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6240195e142f0749829f0eb1858bd2c"></a>
bool *&#160;</td><td class="memItemRight" valign="bottom"><b>imprinted</b></td></tr>
<tr class="separator:ac6240195e142f0749829f0eb1858bd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
BaseConnection Parameters</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2e5c5dc9160e0562c436e5988e0f22a3"></a>List of parameters needed from the <a class="el" href="classPV_1_1BaseConnection.html">BaseConnection</a> class </p>
</td></tr>
<tr class="memitem:a36baac63ad563650145cb6244257311d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36baac63ad563650145cb6244257311d"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:a36baac63ad563650145cb6244257311d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a189b39a328f1335128c383e9cfe40d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a189b39a328f1335128c383e9cfe40d"></a>
<a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parent</b></td></tr>
<tr class="separator:a0a189b39a328f1335128c383e9cfe40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174e35722eaab21cd38eb2908f8903a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a174e35722eaab21cd38eb2908f8903a7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>connId</b></td></tr>
<tr class="separator:a174e35722eaab21cd38eb2908f8903a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0b03dae570319f6831254008fafa05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb0b03dae570319f6831254008fafa05"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>preLayerName</b></td></tr>
<tr class="separator:acb0b03dae570319f6831254008fafa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16807530cf6b6689296abfd2513a7d10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16807530cf6b6689296abfd2513a7d10"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>postLayerName</b></td></tr>
<tr class="separator:a16807530cf6b6689296abfd2513a7d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67eb85575bd12f1fc83d41efc0773dab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67eb85575bd12f1fc83d41efc0773dab"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pre</b></td></tr>
<tr class="separator:a67eb85575bd12f1fc83d41efc0773dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795cb74f306f0f67a014c32e1632c066"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a795cb74f306f0f67a014c32e1632c066"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>post</b></td></tr>
<tr class="separator:a795cb74f306f0f67a014c32e1632c066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85bfd842d7406c7a0f2668fdf31fe38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab85bfd842d7406c7a0f2668fdf31fe38"></a>
ChannelType&#160;</td><td class="memItemRight" valign="bottom"><b>channel</b></td></tr>
<tr class="separator:ab85bfd842d7406c7a0f2668fdf31fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d432cd907a0ea9cf0c6a8194e9fb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859d432cd907a0ea9cf0c6a8194e9fb6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numAxonalArborLists</b></td></tr>
<tr class="separator:a859d432cd907a0ea9cf0c6a8194e9fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4695a78d9aa68b33b1a597e1ef167fd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4695a78d9aa68b33b1a597e1ef167fd3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>plasticityFlag</b></td></tr>
<tr class="separator:a4695a78d9aa68b33b1a597e1ef167fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b388826683512d43ec52f6c2f83469"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25b388826683512d43ec52f6c2f83469"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>convertRateToSpikeCount</b></td></tr>
<tr class="separator:a25b388826683512d43ec52f6c2f83469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b5c297a06ad9ecf51e0280f93e89d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73b5c297a06ad9ecf51e0280f93e89d2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>receiveGpu</b></td></tr>
<tr class="separator:a73b5c297a06ad9ecf51e0280f93e89d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b667614aa0a284156e2f3c3e14521e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02b667614aa0a284156e2f3c3e14521e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initializeFromCheckpointFlag</b></td></tr>
<tr class="separator:a02b667614aa0a284156e2f3c3e14521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951a07a28e41920e16ca105ab1ceaba3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a951a07a28e41920e16ca105ab1ceaba3"></a>
<a class="el" href="classPV_1_1BaseConnectionProbe.html">BaseConnectionProbe</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>probes</b></td></tr>
<tr class="separator:a951a07a28e41920e16ca105ab1ceaba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa983cbd4a723721201f2d22a1b0814a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa983cbd4a723721201f2d22a1b0814a0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numProbes</b></td></tr>
<tr class="separator:aa983cbd4a723721201f2d22a1b0814a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426863a787e04966a32a1eeb4205bed4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a426863a787e04966a32a1eeb4205bed4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initInfoCommunicatedFlag</b></td></tr>
<tr class="separator:a426863a787e04966a32a1eeb4205bed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41ef89416d718442dc48a2b024a85a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af41ef89416d718442dc48a2b024a85a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dataStructuresAllocatedFlag</b></td></tr>
<tr class="separator:af41ef89416d718442dc48a2b024a85a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2de21164586d22332c13aa2fd5116ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2de21164586d22332c13aa2fd5116ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initialValuesSetFlag</b></td></tr>
<tr class="separator:ac2de21164586d22332c13aa2fd5116ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67faf9e8d0dec06f57c5db4c596f411"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae67faf9e8d0dec06f57c5db4c596f411"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDelayArraySize</b> ()</td></tr>
<tr class="separator:ae67faf9e8d0dec06f57c5db4c596f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae30bac5b87e27c096e160da7a8b07c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#aae30bac5b87e27c096e160da7a8b07c8">ioParam_preLayerName</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:aae30bac5b87e27c096e160da7a8b07c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">preLayerName: Specifies the connection's pre layer  <a href="#aae30bac5b87e27c096e160da7a8b07c8">More...</a><br /></td></tr>
<tr class="separator:aae30bac5b87e27c096e160da7a8b07c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19364a0244cb16b0025ed2b34a053c12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a19364a0244cb16b0025ed2b34a053c12">ioParam_postLayerName</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a19364a0244cb16b0025ed2b34a053c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">postLayerName: Specifies the connection's post layer  <a href="#a19364a0244cb16b0025ed2b34a053c12">More...</a><br /></td></tr>
<tr class="separator:a19364a0244cb16b0025ed2b34a053c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad979d27f6d1477c630628323dca3fb12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ad979d27f6d1477c630628323dca3fb12">ioParam_delay</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:ad979d27f6d1477c630628323dca3fb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">delay: Specifies delay(s) which the post layer will receive data  <a href="#ad979d27f6d1477c630628323dca3fb12">More...</a><br /></td></tr>
<tr class="separator:ad979d27f6d1477c630628323dca3fb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b7d91e993091877cc1dc5ab18c488b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8b7d91e993091877cc1dc5ab18c488b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ae8b7d91e993091877cc1dc5ab18c488b">ioParam_numAxonalArbors</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:ae8b7d91e993091877cc1dc5ab18c488b"><td class="mdescLeft">&#160;</td><td class="mdescRight">numAxonalArbors: Specifies the number of arbors to use in this connection <br /></td></tr>
<tr class="separator:ae8b7d91e993091877cc1dc5ab18c488b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1902dddd3f69d3fc46f9ec1a63ee2979"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1902dddd3f69d3fc46f9ec1a63ee2979"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a1902dddd3f69d3fc46f9ec1a63ee2979">ioParam_plasticityFlag</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a1902dddd3f69d3fc46f9ec1a63ee2979"><td class="mdescLeft">&#160;</td><td class="mdescRight">plasticityFlag: Specifies if the weights will update <br /></td></tr>
<tr class="separator:a1902dddd3f69d3fc46f9ec1a63ee2979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11736d629526f3c58299f78265e3a61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#aa11736d629526f3c58299f78265e3a61">ioParam_convertRateToSpikeCount</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:aa11736d629526f3c58299f78265e3a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">preActivityIsNotRate: If true, pre activity is spike rate. If false, pre activity is value  <a href="#aa11736d629526f3c58299f78265e3a61">More...</a><br /></td></tr>
<tr class="separator:aa11736d629526f3c58299f78265e3a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1121921926614fb4af7303fdb91542e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1121921926614fb4af7303fdb91542e6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a1121921926614fb4af7303fdb91542e6">ioParam_receiveGpu</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a1121921926614fb4af7303fdb91542e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">receiveGpu: If true and PetaVision was compiled with GPU acceleration, the connection uses the GPU to update the postsynaptic layer's GSyn. If compiled without GPU acceleration, this flag is ignored. <br /></td></tr>
<tr class="separator:a1121921926614fb4af7303fdb91542e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acb8e53bffb55c4fabaef0ebf88b35f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a6acb8e53bffb55c4fabaef0ebf88b35f">ioParam_initializeFromCheckpointFlag</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a6acb8e53bffb55c4fabaef0ebf88b35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializeFromCheckpointFlag: If set to true, initialize using checkpoint direcgtory set in <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>.  <a href="#a6acb8e53bffb55c4fabaef0ebf88b35f">More...</a><br /></td></tr>
<tr class="separator:a6acb8e53bffb55c4fabaef0ebf88b35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae110837cca7d61443b745992c253778f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ae110837cca7d61443b745992c253778f">getNumProbes</a> ()</td></tr>
<tr class="separator:ae110837cca7d61443b745992c253778f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f3a5e41b57a6d58e1c41e2b2254ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPV_1_1BaseConnectionProbe.html">BaseConnectionProbe</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a33f3a5e41b57a6d58e1c41e2b2254ff9">getProbe</a> (int i)</td></tr>
<tr class="separator:a33f3a5e41b57a6d58e1c41e2b2254ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60370ef49a456d96e388a646c55112b8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a60370ef49a456d96e388a646c55112b8">initializeDelays</a> (const float *fDelayArray, int size)</td></tr>
<tr class="separator:a60370ef49a456d96e388a646c55112b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0c77b79042285b7608f7eeb052851a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ade0c77b79042285b7608f7eeb052851a">decodeChannel</a> (int channel_code, ChannelType *channel_type)</td></tr>
<tr class="separator:ade0c77b79042285b7608f7eeb052851a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
HyPerConn Parameters</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp64430ea075972e7b708d704854205067"></a>List of parameters needed from the <a class="el" href="classPV_1_1HyPerConn.html">HyPerConn</a> class </p>
</td></tr>
<tr class="memitem:a40deeb8556de00595f6479bf2a5bb18d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a40deeb8556de00595f6479bf2a5bb18d">ioParam_channelCode</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a40deeb8556de00595f6479bf2a5bb18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">channelCode: Specifies which channel in the post layer this connection is attached to  <a href="#a40deeb8556de00595f6479bf2a5bb18d">More...</a><br /></td></tr>
<tr class="separator:a40deeb8556de00595f6479bf2a5bb18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef93a9e9830b4e6b6a7a758c1c031eb8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#aef93a9e9830b4e6b6a7a758c1c031eb8">ioParam_weightInitType</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:aef93a9e9830b4e6b6a7a758c1c031eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">weightInitType: Specifies the initialization method of weights  <a href="#aef93a9e9830b4e6b6a7a758c1c031eb8">More...</a><br /></td></tr>
<tr class="separator:aef93a9e9830b4e6b6a7a758c1c031eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eecf5321dc03a7c38c0091810f84503"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a7eecf5321dc03a7c38c0091810f84503">ioParam_weightUpdatePeriod</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a7eecf5321dc03a7c38c0091810f84503"><td class="mdescLeft">&#160;</td><td class="mdescRight">plasticityFlag: Specifies if the weights will be updated  <a href="#a7eecf5321dc03a7c38c0091810f84503">More...</a><br /></td></tr>
<tr class="separator:a7eecf5321dc03a7c38c0091810f84503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4047adecf3bacf506a094661c11e88d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4047adecf3bacf506a094661c11e88d2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a4047adecf3bacf506a094661c11e88d2">ioParam_initialWeightUpdateTime</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a4047adecf3bacf506a094661c11e88d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialWeightUpdateTime: If plasticity flag is set, specifies the inital weight update time; ignored if triggerFlag = true <br /></td></tr>
<tr class="separator:a4047adecf3bacf506a094661c11e88d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3cca4d6175ffddc8098860650f2c98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f3cca4d6175ffddc8098860650f2c98"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a1f3cca4d6175ffddc8098860650f2c98">ioParam_triggerFlag</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a1f3cca4d6175ffddc8098860650f2c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">triggerFlag: If plasticity flag is set, allows weight updates to be triggered off layers <br /></td></tr>
<tr class="separator:a1f3cca4d6175ffddc8098860650f2c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fd8dfe6fa9caae1cdc687f1fe7bb47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13fd8dfe6fa9caae1cdc687f1fe7bb47"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a13fd8dfe6fa9caae1cdc687f1fe7bb47">ioParam_triggerLayerName</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a13fd8dfe6fa9caae1cdc687f1fe7bb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">triggerLayerName: If trigger flag is set, specifies the layer to trigger off of <br /></td></tr>
<tr class="separator:a13fd8dfe6fa9caae1cdc687f1fe7bb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5060c74c19d2e78a93b48aa87d62f72e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a5060c74c19d2e78a93b48aa87d62f72e">ioParam_triggerOffset</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a5060c74c19d2e78a93b48aa87d62f72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">triggerOffset: If trigger flag is set, triggers &lt;triggerOffset&gt; timesteps before target trigger  <a href="#a5060c74c19d2e78a93b48aa87d62f72e">More...</a><br /></td></tr>
<tr class="separator:a5060c74c19d2e78a93b48aa87d62f72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a912d4cd3452a9f2c6443f7a6c47e0c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a1a912d4cd3452a9f2c6443f7a6c47e0c">ioParam_pvpatchAccumulateType</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a1a912d4cd3452a9f2c6443f7a6c47e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">pvpatchAccumulateType: Specifies the method to accumulate synaptic input  <a href="#a1a912d4cd3452a9f2c6443f7a6c47e0c">More...</a><br /></td></tr>
<tr class="separator:a1a912d4cd3452a9f2c6443f7a6c47e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f1d451f1c98dfb48a69ae680fac093"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a68f1d451f1c98dfb48a69ae680fac093">ioParam_writeStep</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a68f1d451f1c98dfb48a69ae680fac093"><td class="mdescLeft">&#160;</td><td class="mdescRight">writeStep: Specifies the write period of the connection.  <a href="#a68f1d451f1c98dfb48a69ae680fac093">More...</a><br /></td></tr>
<tr class="separator:a68f1d451f1c98dfb48a69ae680fac093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab883cfba03b5cf3c1d2eda83347ff85a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab883cfba03b5cf3c1d2eda83347ff85a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#ab883cfba03b5cf3c1d2eda83347ff85a">ioParam_initialWriteTime</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:ab883cfba03b5cf3c1d2eda83347ff85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialWriteTime: If writeStep is &gt;= 0, sets the initial write time of the connection. <br /></td></tr>
<tr class="separator:ab883cfba03b5cf3c1d2eda83347ff85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ea2656a3e88a6c85c386bdc98aeed6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43ea2656a3e88a6c85c386bdc98aeed6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a43ea2656a3e88a6c85c386bdc98aeed6">ioParam_writeCompressedWeights</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a43ea2656a3e88a6c85c386bdc98aeed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">writeCompressedWeights: If writeStep &gt;= 0, weights written out are bytes as opposed to floats. <br /></td></tr>
<tr class="separator:a43ea2656a3e88a6c85c386bdc98aeed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3e28af3168d08be0ed8be234f96825"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a9c3e28af3168d08be0ed8be234f96825">ioParam_writeCompressedCheckpoints</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a9c3e28af3168d08be0ed8be234f96825"><td class="mdescLeft">&#160;</td><td class="mdescRight">writeCompressedCheckpoints: Checkpoint weights are written compressed.  <a href="#a9c3e28af3168d08be0ed8be234f96825">More...</a><br /></td></tr>
<tr class="separator:a9c3e28af3168d08be0ed8be234f96825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3649f5e5ea28f2c92dea47cd0a1f7d1b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a3649f5e5ea28f2c92dea47cd0a1f7d1b">ioParam_selfFlag</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a3649f5e5ea28f2c92dea47cd0a1f7d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">selfFlag: Indicates if pre and post is the same layer.  <a href="#a3649f5e5ea28f2c92dea47cd0a1f7d1b">More...</a><br /></td></tr>
<tr class="separator:a3649f5e5ea28f2c92dea47cd0a1f7d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3a003b49aa120aa722a95bd78b58a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#aad3a003b49aa120aa722a95bd78b58a4">ioParam_combine_dW_with_W_flag</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:aad3a003b49aa120aa722a95bd78b58a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">combine_dW_with_W_flag: If plasticity flag is set, specifies if dW buffer is allocated  <a href="#aad3a003b49aa120aa722a95bd78b58a4">More...</a><br /></td></tr>
<tr class="separator:aad3a003b49aa120aa722a95bd78b58a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7430896367ad5c00a5eed225fe39357a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a7430896367ad5c00a5eed225fe39357a">ioParam_nxp</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a7430896367ad5c00a5eed225fe39357a"><td class="mdescLeft">&#160;</td><td class="mdescRight">nxp: Specifies the x patch size  <a href="#a7430896367ad5c00a5eed225fe39357a">More...</a><br /></td></tr>
<tr class="separator:a7430896367ad5c00a5eed225fe39357a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab881899881d20fa79570cc7542fe781b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#ab881899881d20fa79570cc7542fe781b">ioParam_nyp</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:ab881899881d20fa79570cc7542fe781b"><td class="mdescLeft">&#160;</td><td class="mdescRight">nyp: Specifies the y patch size  <a href="#ab881899881d20fa79570cc7542fe781b">More...</a><br /></td></tr>
<tr class="separator:ab881899881d20fa79570cc7542fe781b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc15fae6b04dd1f91a2fff7b038a45e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc15fae6b04dd1f91a2fff7b038a45e1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#adc15fae6b04dd1f91a2fff7b038a45e1">ioParam_nxpShrunken</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:adc15fae6b04dd1f91a2fff7b038a45e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">nxpShrunken: Specifies a shrunken patch size (deprecated) <br /></td></tr>
<tr class="separator:adc15fae6b04dd1f91a2fff7b038a45e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa541c72ca26ed0963eb75f326ac9c532"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa541c72ca26ed0963eb75f326ac9c532"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#aa541c72ca26ed0963eb75f326ac9c532">ioParam_nypShrunken</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:aa541c72ca26ed0963eb75f326ac9c532"><td class="mdescLeft">&#160;</td><td class="mdescRight">nypShrunken: Specifies a shrunken patch size (deprecated) <br /></td></tr>
<tr class="separator:aa541c72ca26ed0963eb75f326ac9c532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025079c2ec0cd80680e684611baa92e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a025079c2ec0cd80680e684611baa92e6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a025079c2ec0cd80680e684611baa92e6">ioParam_nfp</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a025079c2ec0cd80680e684611baa92e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">nfp: Specifies the post feature patch size <br /></td></tr>
<tr class="separator:a025079c2ec0cd80680e684611baa92e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b7d44d20ba90109a548e8d79381bd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1b7d44d20ba90109a548e8d79381bd8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#ad1b7d44d20ba90109a548e8d79381bd8">ioParam_shrinkPatches</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:ad1b7d44d20ba90109a548e8d79381bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">shrinkPatches: Optimization for shrinking a patch to it's non-zero values <br /></td></tr>
<tr class="separator:ad1b7d44d20ba90109a548e8d79381bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce3c291d3f641229a20f8dea1597cb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afce3c291d3f641229a20f8dea1597cb8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#afce3c291d3f641229a20f8dea1597cb8">ioParam_shrinkPatchesThresh</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:afce3c291d3f641229a20f8dea1597cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">shrinkPatchesThresh: If shrinkPatches flag is set, specifies threshold to consider weight as zero <br /></td></tr>
<tr class="separator:afce3c291d3f641229a20f8dea1597cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe5d2532fc8956bd5ee41a1207883fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbe5d2532fc8956bd5ee41a1207883fd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#adbe5d2532fc8956bd5ee41a1207883fd">ioParam_updateGSynFromPostPerspective</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:adbe5d2532fc8956bd5ee41a1207883fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">updateGSynFromPostPerspective: Specifies if the connection should push from pre or pull from post. <br /></td></tr>
<tr class="separator:adbe5d2532fc8956bd5ee41a1207883fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ead8f1467a8e0f3f3683814c5e5aa33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ead8f1467a8e0f3f3683814c5e5aa33"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a8ead8f1467a8e0f3f3683814c5e5aa33">ioParam_dWMax</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a8ead8f1467a8e0f3f3683814c5e5aa33"><td class="mdescLeft">&#160;</td><td class="mdescRight">dWMax: If plasticity flag is set, specifies the learning rate of the weight updates. <br /></td></tr>
<tr class="separator:a8ead8f1467a8e0f3f3683814c5e5aa33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4013650e7dd7ef01cb1c88e015754f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#ab4013650e7dd7ef01cb1c88e015754f8">ioParam_normalizeMethod</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:ab4013650e7dd7ef01cb1c88e015754f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalizeMethod: Specifies the normalization method for weights  <a href="#ab4013650e7dd7ef01cb1c88e015754f8">More...</a><br /></td></tr>
<tr class="separator:ab4013650e7dd7ef01cb1c88e015754f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36986de697e5eecda09a55abcbc0af1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36986de697e5eecda09a55abcbc0af1a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a36986de697e5eecda09a55abcbc0af1a">ioParam_normalizeGroupName</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a36986de697e5eecda09a55abcbc0af1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">groupNormalizerName: If normalizeMethod is set to "normalizeGroup", sets the name of the normalization group for this connection. <br /></td></tr>
<tr class="separator:a36986de697e5eecda09a55abcbc0af1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62f22848fdfeccc8f398c5982b5cf11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac62f22848fdfeccc8f398c5982b5cf11"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#ac62f22848fdfeccc8f398c5982b5cf11">ioParam_keepKernelsSynchronized</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:ac62f22848fdfeccc8f398c5982b5cf11"><td class="mdescLeft">&#160;</td><td class="mdescRight">keepKernelsSynchronized: If using sharedWeights and plasticityFlag, sets if kernels should be synchronized during the run. <br /></td></tr>
<tr class="separator:ac62f22848fdfeccc8f398c5982b5cf11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1822836200e3e6eb36131cee47244376"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1822836200e3e6eb36131cee47244376"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a1822836200e3e6eb36131cee47244376">ioParam_useMask</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a1822836200e3e6eb36131cee47244376"><td class="mdescLeft">&#160;</td><td class="mdescRight">useMask: Specifies if this connection is using a post mask for learning <br /></td></tr>
<tr class="separator:a1822836200e3e6eb36131cee47244376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa166d55572f6ce8fcbbff9d10fb1033a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa166d55572f6ce8fcbbff9d10fb1033a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#aa166d55572f6ce8fcbbff9d10fb1033a">ioParam_maskLayerName</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:aa166d55572f6ce8fcbbff9d10fb1033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">maskLayerName: If using mask, specifies the layer to use as a binary mask layer <br /></td></tr>
<tr class="separator:aa166d55572f6ce8fcbbff9d10fb1033a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c58d4d38f1bf39dd37111482a697951"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a0c58d4d38f1bf39dd37111482a697951">ioParam_maskFeatureIdx</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a0c58d4d38f1bf39dd37111482a697951"><td class="mdescLeft">&#160;</td><td class="mdescRight">maskLayerName: If using mask, specifies which feature dim to use for the mask  <a href="#a0c58d4d38f1bf39dd37111482a697951">More...</a><br /></td></tr>
<tr class="separator:a0c58d4d38f1bf39dd37111482a697951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5726211e5f9794202570f486ac23af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#aad5726211e5f9794202570f486ac23af">ioParam_gpuGroupIdx</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:aad5726211e5f9794202570f486ac23af"><td class="mdescLeft">&#160;</td><td class="mdescRight">gpuGroupIdx: All connections in the same group uses the same GPU memory for weights  <a href="#aad5726211e5f9794202570f486ac23af">More...</a><br /></td></tr>
<tr class="separator:aad5726211e5f9794202570f486ac23af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9a783eda36f70f2d59b06a62f9e716"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea9a783eda36f70f2d59b06a62f9e716"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#aea9a783eda36f70f2d59b06a62f9e716">ioParam_preDataLocal</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:aea9a783eda36f70f2d59b06a62f9e716"><td class="mdescLeft">&#160;</td><td class="mdescRight">preDataLocal: If not using CUDNN, specifies if preData should be in local memory. This parameter is ignored if PetaVision was compiled without GPU acceleration. <br /></td></tr>
<tr class="separator:aea9a783eda36f70f2d59b06a62f9e716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba70589af533f080ee0e208f082ed07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a2ba70589af533f080ee0e208f082ed07">ioParam_numXLocal</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a2ba70589af533f080ee0e208f082ed07"><td class="mdescLeft">&#160;</td><td class="mdescRight">numXLocal: Specifies number of local threads to run in x direction  <a href="#a2ba70589af533f080ee0e208f082ed07">More...</a><br /></td></tr>
<tr class="separator:a2ba70589af533f080ee0e208f082ed07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a78481a6044538a9778757978cc41bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a0a78481a6044538a9778757978cc41bd">ioParam_numYLocal</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a0a78481a6044538a9778757978cc41bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">numYLocal: Specifies number of local threads to run in xydirection  <a href="#a0a78481a6044538a9778757978cc41bd">More...</a><br /></td></tr>
<tr class="separator:a0a78481a6044538a9778757978cc41bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9450a8fe2156d3afad5c5def72fc6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1HyPerConn.html#a7f9450a8fe2156d3afad5c5def72fc6e">ioParam_numFLocal</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a7f9450a8fe2156d3afad5c5def72fc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">numYLocal: Specifies number of local threads to run in xydirection  <a href="#a7f9450a8fe2156d3afad5c5def72fc6e">More...</a><br /></td></tr>
<tr class="separator:a7f9450a8fe2156d3afad5c5def72fc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a026f6b068710cc1620e60c6dfdfd3c41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::adjustAxonalArbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arborId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<ul>
<li>Each neuron in the pre-synaptic layer projects a number of axonal arbors to the post-synaptic layer (Can they be projected accross columns too?).</li>
<li>numAxons is the number of axonal arbors projected by each neuron.</li>
<li>Each axonal arbor (PVAxonalArbor) connects to a patch of neurons in the post-synaptic layer.</li>
<li>The PVAxonalArbor structure contains STDP P variable.</li>
<li></li>
</ul>
<p>REMARKS:</p><ul>
<li>numArbors = (nxPre + 2*prePad)*(nyPre+2*prePad) = nxexPre * nyexPre This is the total number of weight patches for a given arbor. Is the number of pre-synaptic neurons including margins.</li>
<li>activity and STDP M variable are extended into margins</li>
</ul>

</div>
</div>
<a class="anchor" id="ab9ec4d55a7a2fea63397c1f2572e114d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::ImprintConn::allocateDataStructures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>allocateDataStructures is used to allocate blocks of memory whose size and arrangement depend on parameters. (For example, <a class="el" href="classPV_1_1HyPerConn.html">HyPerConn</a> allocates weight patches and data patches). After a connection is constructed, it is not properly initialized until <a class="el" href="classPV_1_1HyPerConn.html#a18a5cc03609f6d283f62410c7243e019">communicateInitInfo()</a>, <a class="el" href="classPV_1_1ImprintConn.html#ab9ec4d55a7a2fea63397c1f2572e114d">allocateDataStructures()</a>, and <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> have been called.</p>
<p>Return values: PV_POSTPONE means that <a class="el" href="classPV_1_1ImprintConn.html#ab9ec4d55a7a2fea63397c1f2572e114d">allocateDataStructures()</a> cannot be run until other layers'/connections' own <a class="el" href="classPV_1_1ImprintConn.html#ab9ec4d55a7a2fea63397c1f2572e114d">allocateDataStructures()</a> have been run successfully.</p>
<p>PV_SUCCESS and PV_FAILURE have their usual meanings.</p>
<p><a class="el" href="classPV_1_1ImprintConn.html#ab9ec4d55a7a2fea63397c1f2572e114d">allocateDataStructures()</a> is typically called by the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run() method. </p>

<p>Reimplemented from <a class="el" href="classPV_1_1HyPerConn.html#a70d80fdc9041d539a9ff1e171f91640f">PV::HyPerConn</a>.</p>

</div>
</div>
<a class="anchor" id="a95be5939cf43afbcecce01673dd415ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::allocatePostDeviceWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize OpenCL buffers. This must be called after weights have been allocated. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1CloneConn.html#aaae21b9dded1beb2174ed9206f22fdb7">PV::CloneConn</a>, and <a class="el" href="classPV_1_1TransposeConn.html#a4641feb4ce7bf817f05af07a2d7bce7f">PV::TransposeConn</a>.</p>

</div>
</div>
<a class="anchor" id="a5257b1cbc2eff50e5a6ae15205203e4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::ImprintConn::checkpointRead </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>timeptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual function for reading the state of the connection from the directory specified in cpDir. On exit, *timeptr is the time at which the checkpoint was written. <a class="el" href="classPV_1_1ImprintConn.html#a5257b1cbc2eff50e5a6ae15205203e4c">checkpointRead()</a> should restore the state of the connection completely, so that restarting from a checkpoint is equivalent to having the run continue. </p>

<p>Reimplemented from <a class="el" href="classPV_1_1HyPerConn.html#ab6824a17e0ae283ce8042d63a5b65fe8">PV::HyPerConn</a>.</p>

</div>
</div>
<a class="anchor" id="ae2ce443cf4cfc00219f9834c19c022d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::ImprintConn::checkpointWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpDir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual function for writing the state of the connection to the directory specified in cpDir. <a class="el" href="classPV_1_1ImprintConn.html#ae2ce443cf4cfc00219f9834c19c022d6">checkpointWrite()</a> should save the complete state of the connection, so that restarting from a checkpoint is equivalent to having the run continue. </p>

<p>Reimplemented from <a class="el" href="classPV_1_1HyPerConn.html#a0e91da827bf65c6482c2f0750b4e5b04">PV::HyPerConn</a>.</p>

</div>
</div>
<a class="anchor" id="a18a5cc03609f6d283f62410c7243e019"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::communicateInitInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>communicateInitInfo is used to allow connections and layers to set params and related member variables based on what other layers or connections are doing. (For example, <a class="el" href="classPV_1_1CloneConn.html">CloneConn</a> sets many parameters the same as its originalConn.) After a connection is constructed, it is not properly initialized until <a class="el" href="classPV_1_1HyPerConn.html#a18a5cc03609f6d283f62410c7243e019">communicateInitInfo()</a>, <a class="el" href="classPV_1_1HyPerConn.html#a70d80fdc9041d539a9ff1e171f91640f">allocateDataStructures()</a>, and <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> have been called.</p>
<p>Return values: PV_POSTPONE means that <a class="el" href="classPV_1_1HyPerConn.html#a18a5cc03609f6d283f62410c7243e019">communicateInitInfo()</a> cannot be run until other layers'/connections' own <a class="el" href="classPV_1_1HyPerConn.html#a18a5cc03609f6d283f62410c7243e019">communicateInitInfo()</a> have been run successfully.</p>
<p>PV_SUCCESS and PV_FAILURE have their usual meanings.</p>
<p><a class="el" href="classPV_1_1HyPerConn.html#a18a5cc03609f6d283f62410c7243e019">communicateInitInfo()</a> is typically called by the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run() method. </p>

<p>Reimplemented from <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">PV::BaseConnection</a>.</p>

<p>Reimplemented in <a class="el" href="classPV_1_1OjaSTDPConn.html#a80a809f8995623b3dc192b7c89b2fc80">PV::OjaSTDPConn</a>, <a class="el" href="classPV_1_1LCALIFLateralConn.html#aa469d780ce9ae0f04603c80c2d76c4a8">PV::LCALIFLateralConn</a>, <a class="el" href="classPV_1_1BiLinearConn.html#a6f4a64bdbcd2617c21be012e3bdfa9ed">PV::BiLinearConn</a>, <a class="el" href="classPV_1_1IdentConn.html#a8ab38891828d62979c6444b1e6da49a5">PV::IdentConn</a>, <a class="el" href="classPV_1_1CloneConn.html#a342ec68e74653ca8ef57c458dfc000c4">PV::CloneConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#a0c62972470d72193fb6016322d01e60c">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1PoolingConn.html#a36b22efa5bdc00b50640a6bab277d9b7">PV::PoolingConn</a>, <a class="el" href="classPV_1_1CloneKernelConn.html#a0e9226cff9634838781c3e9b44d41e2c">PV::CloneKernelConn</a>, <a class="el" href="classPV_1_1PlasticCloneConn.html#a8ff66a711a59802a32cbbc522f41c5f0">PV::PlasticCloneConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#aed7999003aa1a2dffb5118ee1b59b5f9">PV::TransposeConn</a>, <a class="el" href="classPV_1_1CopyConn.html#a7cde9de193f5b6c2839e3af747103483">PV::CopyConn</a>, and <a class="el" href="classPV_1_1privateTransposeConn.html#ae14636331de02a1adfa1796d2a567646">PV::privateTransposeConn</a>.</p>

</div>
</div>
<a class="anchor" id="af8abb42b81c1c54e296ba30b96a9b55b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::constructWeights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>REMARKS:</p><ul>
<li>Each neuron in the pre-synaptic layer can project "up" a number of arbors. Each arbor connects to a patch in the post-synaptic layer.</li>
<li>writeTime and writeStep are used to write post-synaptic patches.These patches are written every writeStep.</li>
</ul>

<p>Reimplemented in <a class="el" href="classPV_1_1TransposeConn.html#a23830bb14f2653f62dff61bb4b3b4168">PV::TransposeConn</a>, <a class="el" href="classPV_1_1CloneConn.html#af3701aa952443933dce0e7ad9ec859b3">PV::CloneConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#ab366ac7eb01b34ec95d7c8efb5dd9f5a">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1privateTransposeConn.html#a49460b1294a3e2f492dbfc9001cfedf9">PV::privateTransposeConn</a>, and <a class="el" href="classPV_1_1PoolingConn.html#a86887fbfa2a430e6e3558c3ca04708e8">PV::PoolingConn</a>.</p>

</div>
</div>
<a class="anchor" id="a165c200843c9df6a98be0b17fe17d70c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::createWeights </td>
          <td>(</td>
          <td class="paramtype">PVPatch ***&#160;</td>
          <td class="paramname"><em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arborId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a separate patch of weights for every neuron </p>

</div>
</div>
<a class="anchor" id="ade0c77b79042285b7608f7eeb052851a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int PV::BaseConnection::decodeChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChannelType *&#160;</td>
          <td class="paramname"><em>channel_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type-safe method of translating an integer channel_code into an allowed channel type. If channel_code corresponds to a recognized channel type, *channel_type is set accordingly and the function returns successfully. Otherwise, *channel_type is undefined and the function returns PV_FAILURE. </p>

</div>
</div>
<a class="anchor" id="a6224b373cdf3ed2945009b05384045e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::deliver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses presynaptic layer's activity to modify the postsynaptic GSyn or thread_gSyn </p>

<p>Implements <a class="el" href="classPV_1_1BaseConnection.html#ad66445aef165085c3c1532723343892c">PV::BaseConnection</a>.</p>

<p>Reimplemented in <a class="el" href="classPV_1_1privateTransposeConn.html#addc16c43ed29179a6e7452e338558c09">PV::privateTransposeConn</a>.</p>

</div>
</div>
<a class="anchor" id="a9b52df3960d65adc7ea54cc9d96d1adf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::finalizeUpdate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A virtual function for performing any necessary updates after the normalizers are called. </p>

<p>Reimplemented from <a class="el" href="classPV_1_1BaseConnection.html#af8c45f692f702a2bbcbcda61ca37dcaa">PV::BaseConnection</a>.</p>

<p>Reimplemented in <a class="el" href="classPV_1_1CloneConn.html#aa7087e1458a2b6b7fc67defd6be181a6">PV::CloneConn</a>, <a class="el" href="classPV_1_1PoolingConn.html#a82129c432c8d903890ba1f31e91df4b3">PV::PoolingConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#a58c51b44117bebea00bde177d89a870b">PV::TransposeConn</a>, and <a class="el" href="classPV_1_1privateTransposeConn.html#a9c752c152e410993612e9b6d3fad9b68">PV::privateTransposeConn</a>.</p>

</div>
</div>
<a class="anchor" id="a4be0fa26cb77eeb9639fe050a321d94e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::getConnectionId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the connection's connId (assigned when added to its parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>) </p>

</div>
</div>
<a class="anchor" id="a4156c5a76ca32f25d7c2ed3b2b4d18ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PV::BaseConnection::getConvertRateToSpikeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the connection treats pre-synaptic activity as a not-rate. Returns false if the connection treats pre-synaptic activity as a rate. </p>

</div>
</div>
<a class="anchor" id="a9347ed2d5346fede4e490351926b5da5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PV::BaseConnection::getDataStructuresAllocatedFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true or false, depending on whether <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> has been called successfully. </p>

</div>
</div>
<a class="anchor" id="afe70c6d11aa83fd6c5a5c0c3bda73e72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::getDelay </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arbor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the delay (in timesteps) belonging the given arbor. </p>

</div>
</div>
<a class="anchor" id="a764a2087e925f175e24bd144f4c9c062"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PV::BaseConnection::getInitialValuesSetFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true or false, depending on whether <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> has been called successfully. </p>

</div>
</div>
<a class="anchor" id="ad617960920014f253c2244a915ce5543"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PV::BaseConnection::getInitInfoCommunicatedFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true or false, depending on whether <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> has been called successfully. </p>

</div>
</div>
<a class="anchor" id="a829c6e9c1ea72edce9c41992c295703e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* PV::BaseConnection::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the connection's name </p>

</div>
</div>
<a class="anchor" id="ae110837cca7d61443b745992c253778f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::getNumProbes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of probes that have been attached to this connection </p>

</div>
</div>
<a class="anchor" id="aba4b40893e9e1285c43cd407d4958bc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>* PV::BaseConnection::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the connection's parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>. </p>

</div>
</div>
<a class="anchor" id="a6655f465c3758ccf16762bb29c3924f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::getPreAndPostLayerNames </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPV_1_1PVParams.html">PVParams</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>preLayerNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>postLayerNamePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets *preLayerNamePtr and *postLayerNamePtr according to the preLayerName and postLayerName parameters in the parameter group specified by the name and params arguments. </p>

</div>
</div>
<a class="anchor" id="a33f3a5e41b57a6d58e1c41e2b2254ff9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPV_1_1BaseConnectionProbe.html">BaseConnectionProbe</a>* PV::BaseConnection::getProbe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the probe with the indicated position in the list of probes. It does not do sanity checking on the value of i. </p>

</div>
</div>
<a class="anchor" id="a87773ccfc7e240d78a0421ef4dd8f97b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float PV::HyPerConn::getWMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum allowed weight value </p>

</div>
</div>
<a class="anchor" id="a6e248fc2d82a06bbec93c397bdb51e3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float PV::HyPerConn::getWMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimum allowed weight value </p>

</div>
</div>
<a class="anchor" id="af288d6023bba10bc335703cd63d4e8ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::handleMissingPreAndPostLayerNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">BaseConnection::communicateInitInfo</a> of the params did not set pre- and post- layers. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1FeedbackConn.html#adc5317085f1686eba0f710823e82a044">PV::FeedbackConn</a>.</p>

</div>
</div>
<a class="anchor" id="afca788ce4dea591c69b75e48097ce611"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::inferPreAndPostFromConnName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>preLayerNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>postLayerNamePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default behavior of <a class="el" href="classPV_1_1BaseConnection.html#af288d6023bba10bc335703cd63d4e8ff">BaseConnection::handleMissingPreAndPostLayerNames</a>. It tries to parse the name argument of the connection in the form "PreLayerToPostLayer". Then "PreLayer" put into *preLayerNamePtr and "PostLayer" is put into *postLayerNamePtr, and PV_SUCCESS is returned. If name does not contain the string "To", or if it contains it in more than one place, then PV_FAILURE is returned and *preLayerNamePtr and *postLayerNamePtr are not changed. rank is the rank of the process under MPI; the root process will print a message to stderr if the routine fails; non-root process will not. This routine uses malloc to fill *{pre,post}LayerNamePtr, so the routine calling this one is responsible for freeing them. </p>

</div>
</div>
<a class="anchor" id="ac9a439c2eda66dea4c83fb42135e383e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::initialize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *&#160;</td>
          <td class="paramname"><em>hc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The initialization routine. It should be called during the initialization routine of any derived class.</p>
<p>It sets the name and parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> to the indicated arguments, and calls (via ioParams) the virtual ioParamsFillGroup method, which reads params from the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s params. </p>

</div>
</div>
<a class="anchor" id="a60370ef49a456d96e388a646c55112b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::initializeDelays </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>fDelayArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates the delays array and calls <a class="el" href="classPV_1_1BaseConnection.html#a383eb2713c08082509f74639ee2f8898">setDelay()</a> for each arbor. fDelayArray is an array of length size, of delays, measured in the same units as the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s dt.</p>
<p>If size=0, all delays are set to zero. If size=1, all delays are set to fDelayArray[0] If size=numArbors, delays[k] is calculated from fDelayArray[k]. If size is any other value, it is an error. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1privateTransposeConn.html#a30871d6e99b2ac4b448916a75280dc45">PV::privateTransposeConn</a>.</p>

</div>
</div>
<a class="anchor" id="a556aa9907b6bd34efb829825fb4d96cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::initializeState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>initializeState is used to set the initial values of the connection. If the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s checkpointReadFlag is set, it calls <a class="el" href="classPV_1_1BaseConnection.html#a9cf5f4fb0cc822c4ce25b29e81154f0c">checkpointRead()</a> If not, but the connection's initializeFromCheckpointFlag is set, it calls <a class="el" href="classPV_1_1BaseConnection.html#a583611025463b1d6f01069548417f018">readStateFromCheckpoint()</a>. If neither of these flags is set, it calls setInitialValues. Note that derived classes must implement the methods <a class="el" href="classPV_1_1BaseConnection.html#a9cf5f4fb0cc822c4ce25b29e81154f0c">checkpointRead()</a>, <a class="el" href="classPV_1_1BaseConnection.html#a583611025463b1d6f01069548417f018">readStateFromCheckpoint()</a>, and <a class="el" href="classPV_1_1BaseConnection.html#a53366232c096004e249317148d8e6be3">setInitialValues()</a>.</p>
<p>After a connection is constructed, it is not properly initialized until <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a>, <a class="el" href="classPV_1_1BaseConnection.html#adb315c18857ef272abbcdb49efec961f">allocateDataStructures()</a>, and <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> have been called.</p>
<p>Return values: PV_POSTPONE means that <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> cannot be run until other layers'/connections' own <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> have been run successfully.</p>
<p>PV_SUCCESS and PV_FAILURE have their usual meanings.</p>
<p><a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> is typically called by the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run() method. </p>

</div>
</div>
<a class="anchor" id="afc3e8145f1b9e1210935aeb4732c1df6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::insertProbe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPV_1_1BaseConnectionProbe.html">BaseConnectionProbe</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the given probe to the list of probes. </p>

<p>Reimplemented from <a class="el" href="classPV_1_1BaseConnection.html#ab45f5d3470934a92139919ca17ff4409">PV::BaseConnection</a>.</p>

</div>
</div>
<a class="anchor" id="a40deeb8556de00595f6479bf2a5bb18d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_channelCode </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>channelCode: Specifies which channel in the post layer this connection is attached to </p>
<p>Channels can be -1 for no update, or &gt;= 0 for channel number. <br />
 0 is excitatory, 1 is inhibitory </p>

<p>Reimplemented from <a class="el" href="classPV_1_1BaseConnection.html#a470df62079c60e62e95fd22004a9adb3">PV::BaseConnection</a>.</p>

<p>Reimplemented in <a class="el" href="classPV_1_1GapConn.html#afd79207b0ea5d9c34a823a863d7384ec">PV::GapConn</a>.</p>

</div>
</div>
<a class="anchor" id="aad3a003b49aa120aa722a95bd78b58a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_combine_dW_with_W_flag </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>combine_dW_with_W_flag: If plasticity flag is set, specifies if dW buffer is allocated </p>
<p>dW buffer, if not allocated, will point to weight buffer and accumulate weights as it gets them </p>

<p>Reimplemented in <a class="el" href="classPV_1_1TransposeConn.html#ac84a170f6fe92094a019adeea840b68d">PV::TransposeConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#af5ced18012bdb5891247be9cf698019a">PV::TransposePoolingConn</a>, and <a class="el" href="classPV_1_1IdentConn.html#a8140278c3220fa0511a46f4f8fc57392">PV::IdentConn</a>.</p>

</div>
</div>
<a class="anchor" id="aa11736d629526f3c58299f78265e3a61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::ioParam_convertRateToSpikeCount </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>preActivityIsNotRate: If true, pre activity is spike rate. If false, pre activity is value </p>
<p>The post synaptic layer needs to interpret pre synaptic activity as a spike rate Other situations interpret as a value. This flag sets either one or the other. convertRateToSpikeCount: If true, presynaptic activity should be converted from a rate to a count.</p>
<p>If this flag is true and the presynaptic layer is not spiking, the activity will be interpreted as a spike rate, and will be converted to a spike count when delivering activity to the postsynaptic GSyn buffer. If this flag is false, activity will not be converted. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1IdentConn.html#aec0beb0c363d9ee1126e28dcc0fd5275">PV::IdentConn</a>.</p>

</div>
</div>
<a class="anchor" id="ad979d27f6d1477c630628323dca3fb12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::ioParam_delay </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delay: Specifies delay(s) which the post layer will receive data </p>
<p>: Delays are specified in units of dt, but are rounded to be integer multiples of dt. If delay is a scalar, all arbors of the connection have that value of delay. If delay is an array, the length must match the number of arbors and the arbors are assigned the delays sequentially. </p>

</div>
</div>
<a class="anchor" id="aad5726211e5f9794202570f486ac23af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_gpuGroupIdx </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gpuGroupIdx: All connections in the same group uses the same GPU memory for weights </p>
<p>Specify a group index. An index of -1 means no group (default). This parameter is ignored if PetaVision was compiled without GPU acceleration. </p>

</div>
</div>
<a class="anchor" id="a6acb8e53bffb55c4fabaef0ebf88b35f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::ioParam_initializeFromCheckpointFlag </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initializeFromCheckpointFlag: If set to true, initialize using checkpoint direcgtory set in <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>. </p>
<p>Checkpoint read directory must be set in <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> to initialize from checkpoint. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1CloneConn.html#a3825eb293f2119d5505fc83a24ebd628">PV::CloneConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#a590d09b5f87450984c79ab1def005a66">PV::TransposeConn</a>, <a class="el" href="classPV_1_1CopyConn.html#a42dc009b8395749f0b2326f9096e2172">PV::CopyConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#a9c24552de51130c70070cd159c8c89e7">PV::TransposePoolingConn</a>, and <a class="el" href="classPV_1_1IdentConn.html#a619f30bbde13e36764b2961348886fdf">PV::IdentConn</a>.</p>

</div>
</div>
<a class="anchor" id="a0c58d4d38f1bf39dd37111482a697951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_maskFeatureIdx </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maskLayerName: If using mask, specifies which feature dim to use for the mask </p>
<p>Defaults to -1, which means point wise mask </p>

</div>
</div>
<a class="anchor" id="ab4013650e7dd7ef01cb1c88e015754f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_normalizeMethod </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normalizeMethod: Specifies the normalization method for weights </p>
<p>Weights will be normalized after initialization and after each weight update. Possible choices are:</p><ul>
<li><a class="el" href="classPV_1_1NormalizeSum.html">normalizeSum</a>: Normalization where sum of weights add up to strength</li>
<li><a class="el" href="classPV_1_1NormalizeL2.html">normalizeL2</a>: Normaliztion method where L2 of weights add up to strength</li>
<li><a class="el" href="classPV_1_1NormalizeMax.html">normalizeMax</a>: Normaliztion method where Max is clamped at strength</li>
<li><a class="el" href="classPV_1_1NormalizeContrastZeroMean.html">normalizeContrastZeroMean</a>: Normalization method for a weight with specified mean and std</li>
<li><a class="el" href="">normalizeScale</a>: TODO</li>
<li>none: Do not normalize</li>
</ul>
<p>Further parameters are needed depending on initialization type. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1TransposeConn.html#a62b7a066817bfb908343ede34a3993f0">PV::TransposeConn</a>, <a class="el" href="classPV_1_1CloneConn.html#a449832633feeaaad2a98a6de39989c8d">PV::CloneConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#ab585df28b46ff665dab1e60c83f7965c">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1IdentConn.html#a0713c5a6cebe76e8f57f8912fc5e05f4">PV::IdentConn</a>, <a class="el" href="classPV_1_1PoolingConn.html#a15e97a1125ff710e7013b3836fe90dfd">PV::PoolingConn</a>, and <a class="el" href="classPV_1_1GapConn.html#a4d19b6c107559a90f5155bd1371f4e88">PV::GapConn</a>.</p>

</div>
</div>
<a class="anchor" id="a7f9450a8fe2156d3afad5c5def72fc6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_numFLocal </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>numYLocal: Specifies number of local threads to run in xydirection </p>
<p>Only set if receiving from gpu. Not used if using receive CUDNN from post. If using preDataLocal and recv form post, must be set to 1. numXLocal * numYLocal * numFLocal must be less than the amount of local threads specified by the hardware. Must be set to 1. This parameter is ignored if PetaVision was compiled without GPU acceleration. </p>

</div>
</div>
<a class="anchor" id="a2ba70589af533f080ee0e208f082ed07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_numXLocal </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>numXLocal: Specifies number of local threads to run in x direction </p>
<p>Only set if receiving from gpu. Not used if using receive CUDNN from post. This parameter is ignored if PetaVision was compiled without GPU acceleration. </p>

</div>
</div>
<a class="anchor" id="a0a78481a6044538a9778757978cc41bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_numYLocal </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>numYLocal: Specifies number of local threads to run in xydirection </p>
<p>Only set if receiving from gpu. Not used if using receive CUDNN from post. Must be divisible by post layer x size. numXLocal * numYLocal * numFLocal must be less than the amount of local threads specified by the hardware. This parameter is ignored if PetaVision was compiled without GPU acceleration. </p>

</div>
</div>
<a class="anchor" id="a7430896367ad5c00a5eed225fe39357a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_nxp </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>nxp: Specifies the x patch size </p>
<p>If one pre to many post, nxp restricted to many * an odd number If many pre to one post or one pre to one post, nxp restricted to an odd number </p>

<p>Reimplemented in <a class="el" href="classPV_1_1CloneConn.html#ab7b24a0e7b02af94c3eb01238db153ee">PV::CloneConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#a0f950e3472c4150c392de17c41b84a0d">PV::TransposeConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#a8ea89dc93584baac803daa1703f23667">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1IdentConn.html#a656573bf608287fba86c8dabdc60ec6f">PV::IdentConn</a>, and <a class="el" href="classPV_1_1CopyConn.html#a6f38249cbecef293515d7bfd6cb0270f">PV::CopyConn</a>.</p>

</div>
</div>
<a class="anchor" id="ab881899881d20fa79570cc7542fe781b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_nyp </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>nyp: Specifies the y patch size </p>
<p>If one pre to many post, nyp restricted to many * an odd number If many pre to one post or one pre to one post, nyp restricted to an odd number </p>

<p>Reimplemented in <a class="el" href="classPV_1_1CloneConn.html#a7ab8ed5747a38e166cd64d47a47ac729">PV::CloneConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#aacb2be4f8fdbee569aa12be04998cb31">PV::TransposeConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#a28d573563292d1ddb9cf454578696731">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1CopyConn.html#a24d90a54bc6080c81aeed0411b682959">PV::CopyConn</a>, and <a class="el" href="classPV_1_1IdentConn.html#a6bae97a508a9e77bf2461b1cfdedb674">PV::IdentConn</a>.</p>

</div>
</div>
<a class="anchor" id="a19364a0244cb16b0025ed2b34a053c12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::ioParam_postLayerName </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>postLayerName: Specifies the connection's post layer </p>
<p>Required parameter </p>

<p>Reimplemented in <a class="el" href="classPV_1_1FeedbackConn.html#ae270a2ef4b7534cc87ecea090b78a10f">PV::FeedbackConn</a>.</p>

</div>
</div>
<a class="anchor" id="aae30bac5b87e27c096e160da7a8b07c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::ioParam_preLayerName </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>preLayerName: Specifies the connection's pre layer </p>
<p>Required parameter </p>

<p>Reimplemented in <a class="el" href="classPV_1_1FeedbackConn.html#aa8edaf330276653b74ab686973c48efc">PV::FeedbackConn</a>.</p>

</div>
</div>
<a class="anchor" id="a1a912d4cd3452a9f2c6443f7a6c47e0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_pvpatchAccumulateType </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pvpatchAccumulateType: Specifies the method to accumulate synaptic input </p>
<p>Possible choices are</p><ul>
<li>convolve: Accumulates through convolution</li>
<li>stochastic: Accumulates through stochastic release</li>
<li>maxpooling: Accumulates through max pooling</li>
<li>sumpooling: Accumulates through sum pooling</li>
</ul>
<p>Defaults to convolve. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1IdentConn.html#a7a553d825344649ef3338e8259a3d9a8">PV::IdentConn</a>.</p>

</div>
</div>
<a class="anchor" id="a3649f5e5ea28f2c92dea47cd0a1f7d1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_selfFlag </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>selfFlag: Indicates if pre and post is the same layer. </p>
<p>The default value for selfFlag should be pre==post, but at the time ioParams(PARAMS_IO_READ) is called, pre and post have not been set. So we read the value with no warning if it's present; if it's absent, set the value to pre==post in the communicateInitInfo stage and issue the using-default-value warning then. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1IdentConn.html#a0eeb6f15e2d5a5557eca2d086062b589">PV::IdentConn</a>.</p>

</div>
</div>
<a class="anchor" id="a5060c74c19d2e78a93b48aa87d62f72e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_triggerOffset </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>triggerOffset: If trigger flag is set, triggers &lt;triggerOffset&gt; timesteps before target trigger </p>
<p>Defaults to 0. </p>

</div>
</div>
<a class="anchor" id="aef93a9e9830b4e6b6a7a758c1c031eb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_weightInitType </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>weightInitType: Specifies the initialization method of weights </p>
<p>Possible choices are</p><ul>
<li><a class="el" href="classPV_1_1InitGauss2DWeightsParams.html">Gauss2DWeight</a>: Initializes weights with a gaussian distribution in x and y over each f</li>
<li><a class="el" href="classPV_1_1InitCocircWeightsParams.html">CoCircWeight</a>: Initializes cocircular weights</li>
<li><a class="el" href="classPV_1_1InitUniformWeightsParams.html">UniformWeight</a>: Initializes weights with a single uniform weight</li>
<li><a class="el" href="classPV_1_1InitSmartWeights.html">SmartWeight</a>: TODO</li>
<li><a class="el" href="">DistributedWeight</a>: TODO</li>
<li><a class="el" href="">ArborWeight</a>: Initializes different weights in different arbors</li>
<li><a class="el" href="">BIDSLateral</a>: TODO</li>
<li><a class="el" href="classPV_1_1InitUniformRandomWeightsParams.html">UniformRandomWeight</a>: Initializes weights with a uniform distribution</li>
<li><a class="el" href="classPV_1_1InitGaussianRandomWeightsParams.html">GaussianRandomWeight</a>: Initializes individual weights with a gaussian distribution</li>
<li><a class="el" href="">GaborWeight</a>: TODO</li>
<li><a class="el" href="">PoolWeight</a>: TODO</li>
<li><a class="el" href="">RuleWeight</a>: TODO</li>
<li><a class="el" href="">SubUnitWeight</a>: TODO</li>
<li><a class="el" href="classPV_1_1InitIdentWeightsParams.html">IdentWeight</a>: Initializes weights for ident conn (one to one with a strength to 1)</li>
<li><a class="el" href="classPV_1_1InitOneToOneWeightsParams.html">OneToOneWeight</a>: Initializes weights as a multiple of the identity matrix</li>
<li><a class="el" href="classPV_1_1InitOneToOneWeightsWithDelaysParams.html">OneToOneWeightsWithDelays</a>: Initializes weights as a multiple of the identity matrix with delays</li>
<li><a class="el" href="classPV_1_1InitSpreadOverArborsWeightsParams.html">SpreadOverArborsWeight</a>: Initializes weights where different part of the weights over different arbors</li>
<li><a class="el" href="">Gauss3DWeight</a>: Initializes weights with a gaussian distribution in x, y, and f</li>
<li><a class="el" href="">Windowed3DGaussWeights</a>: Initializes weights with a gaussian distribution in x, y, and f over windows</li>
<li><a class="el" href="">MTWeight</a>: TODO</li>
<li><a class="el" href="classPV_1_1InitWeightsParams.html">FileWeight</a>: Initializes weights from a specified pvp file.</li>
</ul>
<p>Further parameters are needed depending on initialization type </p>

<p>Reimplemented in <a class="el" href="classPV_1_1CloneConn.html#a7ac82cb150cd151bdf8377dc7654ba68">PV::CloneConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#afa3fa73a1f11019b81c562038365a4cc">PV::TransposeConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#a024aeaeabde2ddd196186a46001d0e0d">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1CopyConn.html#abb72e9f288bad9b3ab28cc11103ecd49">PV::CopyConn</a>, <a class="el" href="classPV_1_1IdentConn.html#af8b760377294a1c464a1836bfc6dfcda">PV::IdentConn</a>, and <a class="el" href="classPV_1_1PoolingConn.html#af8894765e62b6d26597a5b9ff3a7c1d8">PV::PoolingConn</a>.</p>

</div>
</div>
<a class="anchor" id="a7eecf5321dc03a7c38c0091810f84503"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_weightUpdatePeriod </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>plasticityFlag: Specifies if the weights will be updated </p>
<p>weightUpdatePeriod: If plasticity flag is set, specifies the update period of weights </p>

<p>Reimplemented in <a class="el" href="classPV_1_1TransposeConn.html#af9241fbdf006064c36bfad876da57f3f">PV::TransposeConn</a>, <a class="el" href="classPV_1_1CopyConn.html#a3913e2918c033095ace28096ff3efe03">PV::CopyConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#ac554573a074936773d6d0bb66dc9f1d8">PV::TransposePoolingConn</a>, and <a class="el" href="classPV_1_1IdentConn.html#ad3429de8e28ede121315285d9eb9e128">PV::IdentConn</a>.</p>

</div>
</div>
<a class="anchor" id="a9c3e28af3168d08be0ed8be234f96825"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_writeCompressedCheckpoints </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>writeCompressedCheckpoints: Checkpoint weights are written compressed. </p>
<p>The parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> must be writing checkpoints for this flag to be used </p>

<p>Reimplemented in <a class="el" href="classPV_1_1IdentConn.html#a59cb97f5309b695e9d8ba44cd65c1b9e">PV::IdentConn</a>.</p>

</div>
</div>
<a class="anchor" id="a68f1d451f1c98dfb48a69ae680fac093"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::HyPerConn::ioParam_writeStep </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>writeStep: Specifies the write period of the connection. </p>
<p>Defaults to every timestep. -1 to not write at all. </p>

</div>
</div>
<a class="anchor" id="acdcc2c5884ce0776d49e41767ef45797"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::ioParams </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method for reading or writing the params from group in the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s parameters. The group from params is selected using the name of the connection.</p>
<p>Note that ioParams is not virtual. To add parameters in a derived class, override ioParamFillGroup. </p>

</div>
</div>
<a class="anchor" id="a9ab1db3a961dab411b23c233e8d6aa86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::ImprintConn::ioParamsFillGroup </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The virtual method for reading parameters from the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s parameters, and writing to the output params file.</p>
<p><a class="el" href="classPV_1_1BaseConnection.html#ac472aa90048c60c453855f1bb86134aa">BaseConnection::ioParamsFillGroup</a> reads/writes the paremeters preLayerName, postLayerName, channelCode, delay, numAxonalArbors, and convertRateToSpikeCount.</p>
<p>Derived classes with additional parameters typically override ioParamsFillGroup to call the base class's ioParamsFillGroup method and then call ioParam_[parametername] for each of their parameters. The ioParam_[parametername] methods should call the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s ioParamValue() and related methods, to ensure that all parameters that get read also get written to the outputParams-generated file. </p>

<p>Reimplemented from <a class="el" href="classPV_1_1HyPerConn.html#a9d25459925dab07306be9603617c5026">PV::HyPerConn</a>.</p>

</div>
</div>
<a class="anchor" id="acc2b4bf71aab2681497c6be242d695ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float PV::HyPerConn::maxWeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arborId</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actual maximum weight value </p>

<p>Reimplemented in <a class="el" href="classPV_1_1OjaSTDPConn.html#a5d42c3691b39d5eff90464cd50542ea4">PV::OjaSTDPConn</a>, and <a class="el" href="classPV_1_1PoolingConn.html#abbd977c207706e7167e7a64be2faa8bc">PV::PoolingConn</a>.</p>

</div>
</div>
<a class="anchor" id="a3ddf6eccc1fc0db72e0790736e11ff1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float PV::HyPerConn::minWeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arborId</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Actual mininum weight value </p>

<p>Reimplemented in <a class="el" href="classPV_1_1PoolingConn.html#a8c86ff0b972b95ea71dd1baf7bbdbea4">PV::PoolingConn</a>.</p>

</div>
</div>
<a class="anchor" id="ab1a574b1184f310e9e0f16f1ccf4ce0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PV::HyPerConn::needUpdate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual method whose implementation returns true if an the weights should update on the given timestep and false if not. </p>

<p>Implements <a class="el" href="classPV_1_1BaseConnection.html#a6b2742c810f7fcfc91219f09b3174825">PV::BaseConnection</a>.</p>

<p>Reimplemented in <a class="el" href="classPV_1_1TransposePoolingConn.html#a2cbbaecaca94f777bb92157f4ce446eb">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#ab2308dc6eb9dfcb61b420db3b78acf01">PV::TransposeConn</a>, <a class="el" href="classPV_1_1privateTransposeConn.html#aaefa7416f94ec97b719277234c8932e8">PV::privateTransposeConn</a>, and <a class="el" href="classPV_1_1CopyConn.html#ad1d8245d415fe17f3e192350aae603a8">PV::CopyConn</a>.</p>

</div>
</div>
<a class="anchor" id="a62fb1e130c43fed1d4104aa85ce3fb58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::outputProbeParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by HyPerCol::outputParams to output the params groups for probes whose ownership has been transferred to this connection. (Does this need to be virtual?) </p>

<p>Reimplemented from <a class="el" href="classPV_1_1BaseConnection.html#a663d09deb4f978c513ac5e4b6b8dbc89">PV::BaseConnection</a>.</p>

</div>
</div>
<a class="anchor" id="a52fbf973234d44386f383062e7968cb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::outputState </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>last</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual function for writing the state of the connection to file(s) in the output directory. For example, <a class="el" href="classPV_1_1HyPerConn.html">HyPerConn</a> writes the weights to a .pvp file with a schedule defined by writeStep and initialWriteTime. </p>

<p>Implements <a class="el" href="classPV_1_1BaseConnection.html#ad53c07d17427ba6ce9c4a29cc6b7e9bd">PV::BaseConnection</a>.</p>

<p>Reimplemented in <a class="el" href="classPV_1_1OjaSTDPConn.html#a05a2ff7038cc8ba35569d9d99f3afcdd">PV::OjaSTDPConn</a>, and <a class="el" href="classPV_1_1LCALIFLateralConn.html#a2a487d733a51ebf3ad0cd25f563e78c7">PV::LCALIFLateralConn</a>.</p>

</div>
</div>
<a class="anchor" id="aa967ab7bca24afae03b3cabe9a141fc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::postSynapticPatchHead </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kPreEx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>kxPostOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>kyPostOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>kfPostOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dxOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dyOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nxpOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nypOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the head (kxPostOut, kyPostOut) of the post-synaptic patch plus other patch information.  the pre-synaptic k index (extended units)  address of the kx index in post layer (non-extended units) on output  address of the ky index in post layer (non-extended units) on output  address of the kf index in post layer (non-extended units) on output  address of the change in x dimension size of patch (to fit border) on output  address of the change in y dimension size of patch (to fit border) on output  address of x dimension patch size (includes border reduction) on output  address of y dimension patch size (includes border reduction) on output</p>
<p>NOTE: kxPostOut and kyPostOut are always within the post-synaptic non-extended layer because the patch size is reduced at borders </p>

</div>
</div>
<a class="anchor" id="a55f0ecd356e28f638f2d646f30c933bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::preSynapticPatchHead </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kxPost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kyPost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kfPost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>kxPre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>kyPre</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the head (kxPre, kyPre) of a pre-synaptic patch given post-synaptic layer indices.  the post-synaptic kx index (non-extended units)  the post-synaptic ky index (non-extended units)  the post-synaptic kf index  address of the kx index in the pre-synaptic layer (non-extended units) on output  address of the ky index in the pre-synaptic layer (non-extended units) on output</p>
<p>NOTE: kxPre and kyPre may be in the border region </p>

</div>
</div>
<a class="anchor" id="a5672b85261f505ab757e8c54ffc1bef1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::readStateFromCheckpoint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>timeptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual method that uses an existing checkpoint to initialize the connection. <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">BaseConnection::initializeState</a> calls it when initializeFromCheckpointFlag is true. A Subclass may also call this method as part of the implementation of checkpointRead (for example, <a class="el" href="classPV_1_1HyPerConn.html">HyPerConn</a> does this). </p>

<p>Implements <a class="el" href="classPV_1_1BaseConnection.html#a583611025463b1d6f01069548417f018">PV::BaseConnection</a>.</p>

<p>Reimplemented in <a class="el" href="classPV_1_1CloneConn.html#a2682fb7e89128cd03e0706fead4ca72b">PV::CloneConn</a>.</p>

</div>
</div>
<a class="anchor" id="a88fd61a0b40955bb2cb4b5292372a7e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setChannelType </td>
          <td>(</td>
          <td class="paramtype">ChannelType&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the channel to the indicated argument. It is an error to try to change channels after <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> has completed successfully. </p>

</div>
</div>
<a class="anchor" id="a16596840aabceadcca9eeeb5509bb1a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setConvertRateToSpikeCount </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>convertRateToSpikeCountFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the preActivityIsNotRate flag to the indicated argument. It is an error to try to change preActivityIsNotRate after <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> has completed successfully. </p>

</div>
</div>
<a class="anchor" id="a63f62714f2f1410c51bcdd4fe2214920"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setDataStructuresAllocatedFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets the flag returned by <a class="el" href="classPV_1_1BaseConnection.html#a9347ed2d5346fede4e490351926b5da5">getDataStructuresAllocatedFlag()</a> to true. It is public so that the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run method can set it after receiving a successful allocateDataStructures command (this behavior should probably be changed so that BaseConnection::allocateDataStructuresWrapper, not the calling routine, is responsible for setting the flag). </p>

</div>
</div>
<a class="anchor" id="a383eb2713c08082509f74639ee2f8898"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setDelay </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arborId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the delay of the given arbor to the given amount. delay is specified in the same units that the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s dt parameter is specified in. Internally, the delay is set as an integral number of timesteps, specifically round(delay/dt). </p>

</div>
</div>
<a class="anchor" id="a7131cc61ed6ee2101feb720f271a01b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::setInitialValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual method for initializing the connection if we are neither restarting from a checkpoint or initializing the connection from a checkpoint. It should return PV_SUCCESS if successful, or PV_POSTPONE if it needs to wait for other objects to set their initial values before it can set its own initial values. (e.g. <a class="el" href="classPV_1_1TransposeConn.html">TransposeConn</a> has to wait for original conn) </p>

<p>Implements <a class="el" href="classPV_1_1BaseConnection.html#a53366232c096004e249317148d8e6be3">PV::BaseConnection</a>.</p>

<p>Reimplemented in <a class="el" href="classPV_1_1CopyConn.html#a1a28b9879c7322789371f39cfda19697">PV::CopyConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#a7078d6bac3f7b518834e0176445d6dd8">PV::TransposeConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#ad2c7a173c0ddda5636a5e54a4ed16c37">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1PoolingConn.html#a58c8dea49a6acc007455bb06145f0e52">PV::PoolingConn</a>, and <a class="el" href="classPV_1_1privateTransposeConn.html#ab4adde48be8cdc8bb6dbef308c4dee91">PV::privateTransposeConn</a>.</p>

</div>
</div>
<a class="anchor" id="a3f94f2c5bc97b5c5a9697aff6bf83355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setInitialValuesSetFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets the flag returned by <a class="el" href="classPV_1_1BaseConnection.html#a764a2087e925f175e24bd144f4c9c062">getInitialValuesSetFlag()</a> to true. It is public so that the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run method can set it after receiving a successful initializeState command (this behavior should probably be changed so that BaseConnection::allocateDataStructuresWrapper, not the calling routine, is responsible for setting the flag). </p>

</div>
</div>
<a class="anchor" id="afcf50b01e3b0260d971801edafcbb3e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setInitInfoCommunicatedFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets the flag returned by <a class="el" href="classPV_1_1BaseConnection.html#ad617960920014f253c2244a915ce5543">getInitInfoCommunicatedFlag()</a> to true. It is public so that the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run method can set it after receiving a successful communicateInitInfo command (this behavior should probably be changed so that BaseConnection::communicateInitInfoWrapper, not the calling routine, is responsible for setting the flag). </p>

</div>
</div>
<a class="anchor" id="a605ab0c6f896a76244f1775551a7dc7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::setName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the name member variable. It should be called after setParent since it uses the parent's columnId() to print any error messages </p>

</div>
</div>
<a class="anchor" id="a4f6be4f8f8e3001a80d63d67a11f5f95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setNumberOfAxonalArborLists </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numArbors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the number of arbors to the indicated argument. It is an error to try to change numArbors after <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> has completed successfully. </p>

</div>
</div>
<a class="anchor" id="a50d0597598512a94bde243a303997dce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *&#160;</td>
          <td class="paramname"><em>hc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the parent member variable. </p>

</div>
</div>
<a class="anchor" id="abfdd51256f17d3c3d3e126d38eec5c43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setPostSynapticLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td>
          <td class="paramname"><em>post</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the postsynaptic layer to the given layer. It is an error to try to set postLayer after it has already been set, or to call <a class="el" href="classPV_1_1BaseConnection.html#a9bbea821845660de6aa34d12e8bed21a">setPostLayerName()</a> with a NULL argument. </p>

</div>
</div>
<a class="anchor" id="a305b16e794769ffa39e2e5557025c7c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::setPreAndPostLayerNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the pre- and post-synaptic layer names according to the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s params. Virtual to allow subclasses to infer layer names in other ways (for example, <a class="el" href="classPV_1_1FeedbackConn.html">FeedbackConn</a> flips pre- and post- layers from originalConn). </p>

<p>Reimplemented in <a class="el" href="classPV_1_1FeedbackConn.html#ae52a08c9da0edf8458ceaf624f6578c8">PV::FeedbackConn</a>.</p>

</div>
</div>
<a class="anchor" id="ac9ac6677b9533df9fbc991a5788de1c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setPreSynapticLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td>
          <td class="paramname"><em>pre</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the presynaptic layer to the given layer. It is an error to try to set preLayer after it has already been set, or to call <a class="el" href="classPV_1_1BaseConnection.html#aee5a7a38697c6e7ab61502d44daea61f">setPreLayerName()</a> with a NULL argument. </p>

</div>
</div>
<a class="anchor" id="adfb44e745059789fdd528880bcdf64fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::updateStateWrapper </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual function for updating the state of the connection. timed is simulation time, and dt is the time increment between steps. </p>

<p>Implements <a class="el" href="classPV_1_1BaseConnection.html#a25c05fd9460b34359571fde2f83eb4a9">PV::BaseConnection</a>.</p>

</div>
</div>
<a class="anchor" id="a7c5dd9cf14ed977776b25eabd71ee388"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::HyPerConn::writeTimers </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual function for writing timing information. </p>

<p>Implements <a class="el" href="classPV_1_1BaseConnection.html#adf4a1a8ae010fdaa5b3c4b507965a021">PV::BaseConnection</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/bbroompeltz/Documents/PVWebsite/core/pv-core/src/connections/<a class="el" href="ImprintConn_8hpp_source.html">ImprintConn.hpp</a></li>
<li>/Users/bbroompeltz/Documents/PVWebsite/core/pv-core/src/connections/ImprintConn.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>PV</b></li><li class="navelem"><a class="el" href="classPV_1_1ImprintConn.html">ImprintConn</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
