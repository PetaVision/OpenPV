<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>PetaVision: PV::BaseConnection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="PetaVision"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PetaVision
   &#160;<span id="projectnumber">Alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classPV_1_1BaseConnection.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">PV::BaseConnection Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for PV::BaseConnection:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPV_1_1BaseConnection.png" usemap="#PV::BaseConnection_map" alt=""/>
  <map id="PV::BaseConnection_map" name="PV::BaseConnection_map">
<area href="classPV_1_1HyPerConn.html" alt="PV::HyPerConn" shape="rect" coords="0,56,166,80"/>
<area href="classPV_1_1BiLinearConn.html" alt="PV::BiLinearConn" shape="rect" coords="176,112,342,136"/>
<area href="classPV_1_1CloneConn.html" alt="PV::CloneConn" shape="rect" coords="176,168,342,192"/>
<area href="classPV_1_1CopyConn.html" alt="PV::CopyConn" shape="rect" coords="176,224,342,248"/>
<area href="classPV_1_1GapConn.html" alt="PV::GapConn" shape="rect" coords="176,280,342,304"/>
<area href="classPV_1_1IdentConn.html" alt="PV::IdentConn" shape="rect" coords="176,336,342,360"/>
<area href="classPV_1_1ImprintConn.html" alt="PV::ImprintConn" shape="rect" coords="176,392,342,416"/>
<area href="classPV_1_1KernelConn.html" alt="PV::KernelConn" shape="rect" coords="176,448,342,472"/>
<area href="classPV_1_1LCALIFLateralConn.html" alt="PV::LCALIFLateralConn" shape="rect" coords="176,504,342,528"/>
<area href="classPV_1_1MomentumConn.html" alt="PV::MomentumConn" shape="rect" coords="176,560,342,584"/>
<area href="classPV_1_1OjaSTDPConn.html" alt="PV::OjaSTDPConn" shape="rect" coords="176,616,342,640"/>
<area href="classPV_1_1PoolingConn.html" alt="PV::PoolingConn" shape="rect" coords="176,672,342,696"/>
<area href="classPV_1_1privateTransposeConn.html" alt="PV::privateTransposeConn" shape="rect" coords="176,728,342,752"/>
<area href="classPV_1_1TransposeConn.html" alt="PV::TransposeConn" shape="rect" coords="176,784,342,808"/>
<area href="classPV_1_1TransposePoolingConn.html" alt="PV::TransposePoolingConn" shape="rect" coords="176,840,342,864"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3e0a8a65678bfdc6e0467962a6ca4d2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ac3e0a8a65678bfdc6e0467962a6ca4d2">~BaseConnection</a> ()</td></tr>
<tr class="separator:ac3e0a8a65678bfdc6e0467962a6ca4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb315c18857ef272abbcdb49efec961f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#adb315c18857ef272abbcdb49efec961f">allocateDataStructures</a> ()</td></tr>
<tr class="separator:adb315c18857ef272abbcdb49efec961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf5f4fb0cc822c4ce25b29e81154f0c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a9cf5f4fb0cc822c4ce25b29e81154f0c">checkpointRead</a> (const char *cpDir, double *timeptr)=0</td></tr>
<tr class="separator:a9cf5f4fb0cc822c4ce25b29e81154f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4352bfd2a8b96862c089b7fd1e44771a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a4352bfd2a8b96862c089b7fd1e44771a">checkpointWrite</a> (const char *cpDir)=0</td></tr>
<tr class="separator:a4352bfd2a8b96862c089b7fd1e44771a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f5e34647332445a73f07ad02aa5868"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo</a> ()</td></tr>
<tr class="separator:af9f5e34647332445a73f07ad02aa5868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66445aef165085c3c1532723343892c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ad66445aef165085c3c1532723343892c">deliver</a> ()=0</td></tr>
<tr class="separator:ad66445aef165085c3c1532723343892c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c45f692f702a2bbcbcda61ca37dcaa"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#af8c45f692f702a2bbcbcda61ca37dcaa">finalizeUpdate</a> (double timed, double dt)</td></tr>
<tr class="separator:af8c45f692f702a2bbcbcda61ca37dcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7fa97e4e991952782e2d5267dbad6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b7fa97e4e991952782e2d5267dbad6c"></a>
ChannelType&#160;</td><td class="memItemRight" valign="bottom"><b>getChannel</b> ()</td></tr>
<tr class="separator:a3b7fa97e4e991952782e2d5267dbad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be0fa26cb77eeb9639fe050a321d94e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a4be0fa26cb77eeb9639fe050a321d94e">getConnectionId</a> ()</td></tr>
<tr class="separator:a4be0fa26cb77eeb9639fe050a321d94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4156c5a76ca32f25d7c2ed3b2b4d18ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a4156c5a76ca32f25d7c2ed3b2b4d18ab">getConvertRateToSpikeCount</a> ()</td></tr>
<tr class="separator:a4156c5a76ca32f25d7c2ed3b2b4d18ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9347ed2d5346fede4e490351926b5da5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a9347ed2d5346fede4e490351926b5da5">getDataStructuresAllocatedFlag</a> ()</td></tr>
<tr class="separator:a9347ed2d5346fede4e490351926b5da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe70c6d11aa83fd6c5a5c0c3bda73e72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#afe70c6d11aa83fd6c5a5c0c3bda73e72">getDelay</a> (int arbor)</td></tr>
<tr class="separator:afe70c6d11aa83fd6c5a5c0c3bda73e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764a2087e925f175e24bd144f4c9c062"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a764a2087e925f175e24bd144f4c9c062">getInitialValuesSetFlag</a> ()</td></tr>
<tr class="separator:a764a2087e925f175e24bd144f4c9c062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad617960920014f253c2244a915ce5543"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ad617960920014f253c2244a915ce5543">getInitInfoCommunicatedFlag</a> ()</td></tr>
<tr class="separator:ad617960920014f253c2244a915ce5543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829c6e9c1ea72edce9c41992c295703e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a829c6e9c1ea72edce9c41992c295703e">getName</a> ()</td></tr>
<tr class="separator:a829c6e9c1ea72edce9c41992c295703e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4b40893e9e1285c43cd407d4958bc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#aba4b40893e9e1285c43cd407d4958bc0">getParent</a> ()</td></tr>
<tr class="separator:aba4b40893e9e1285c43cd407d4958bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5885dab7c1de917eb154686e1d24e5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5885dab7c1de917eb154686e1d24e5e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getPlasticityFlag</b> ()</td></tr>
<tr class="separator:ae5885dab7c1de917eb154686e1d24e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41b3bfa3e307b90a82278f77fa1fd71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af41b3bfa3e307b90a82278f77fa1fd71"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getPost</b> ()</td></tr>
<tr class="separator:af41b3bfa3e307b90a82278f77fa1fd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd989c8655830efd1bbc5d0d8068657f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd989c8655830efd1bbc5d0d8068657f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getPostLayerName</b> ()</td></tr>
<tr class="separator:abd989c8655830efd1bbc5d0d8068657f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01b5de07581cb4989e617d08c2ef77e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af01b5de07581cb4989e617d08c2ef77e"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getPre</b> ()</td></tr>
<tr class="separator:af01b5de07581cb4989e617d08c2ef77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8183d3bbd51d0a21c50ee31e32d7d138"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8183d3bbd51d0a21c50ee31e32d7d138"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getPreLayerName</b> ()</td></tr>
<tr class="separator:a8183d3bbd51d0a21c50ee31e32d7d138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b875e9de5267029f3675a9cd781b39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8b875e9de5267029f3675a9cd781b39"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getReceiveGpu</b> ()</td></tr>
<tr class="separator:af8b875e9de5267029f3675a9cd781b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556aa9907b6bd34efb829825fb4d96cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState</a> ()</td></tr>
<tr class="separator:a556aa9907b6bd34efb829825fb4d96cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45f5d3470934a92139919ca17ff4409"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ab45f5d3470934a92139919ca17ff4409">insertProbe</a> (<a class="el" href="classPV_1_1BaseConnectionProbe.html">BaseConnectionProbe</a> *p)</td></tr>
<tr class="separator:ab45f5d3470934a92139919ca17ff4409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcc2c5884ce0776d49e41767ef45797"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#acdcc2c5884ce0776d49e41767ef45797">ioParams</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="separator:acdcc2c5884ce0776d49e41767ef45797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac56436c8219192a954518a263d19dcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac56436c8219192a954518a263d19dcb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfAxonalArborLists</b> ()</td></tr>
<tr class="separator:aac56436c8219192a954518a263d19dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663d09deb4f978c513ac5e4b6b8dbc89"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a663d09deb4f978c513ac5e4b6b8dbc89">outputProbeParams</a> ()</td></tr>
<tr class="separator:a663d09deb4f978c513ac5e4b6b8dbc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53c07d17427ba6ce9c4a29cc6b7e9bd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ad53c07d17427ba6ce9c4a29cc6b7e9bd">outputState</a> (double timed, bool last=false)=0</td></tr>
<tr class="separator:ad53c07d17427ba6ce9c4a29cc6b7e9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1508ca0356c7a1fa1c5501c314e7eff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1508ca0356c7a1fa1c5501c314e7eff7"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>postSynapticLayer</b> ()</td></tr>
<tr class="separator:a1508ca0356c7a1fa1c5501c314e7eff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa462c5ad2cedde5a4626b5bb665aa13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa462c5ad2cedde5a4626b5bb665aa13"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>preSynapticLayer</b> ()</td></tr>
<tr class="separator:afa462c5ad2cedde5a4626b5bb665aa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f62714f2f1410c51bcdd4fe2214920"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a63f62714f2f1410c51bcdd4fe2214920">setDataStructuresAllocatedFlag</a> ()</td></tr>
<tr class="separator:a63f62714f2f1410c51bcdd4fe2214920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f94f2c5bc97b5c5a9697aff6bf83355"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a3f94f2c5bc97b5c5a9697aff6bf83355">setInitialValuesSetFlag</a> ()</td></tr>
<tr class="separator:a3f94f2c5bc97b5c5a9697aff6bf83355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf50b01e3b0260d971801edafcbb3e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#afcf50b01e3b0260d971801edafcbb3e2">setInitInfoCommunicatedFlag</a> ()</td></tr>
<tr class="separator:afcf50b01e3b0260d971801edafcbb3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c05fd9460b34359571fde2f83eb4a9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a25c05fd9460b34359571fde2f83eb4a9">updateStateWrapper</a> (double timed, double dt)=0</td></tr>
<tr class="separator:a25c05fd9460b34359571fde2f83eb4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4a1a8ae010fdaa5b3c4b507965a021"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#adf4a1a8ae010fdaa5b3c4b507965a021">writeTimers</a> (FILE *stream)=0</td></tr>
<tr class="separator:adf4a1a8ae010fdaa5b3c4b507965a021"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6526e6b9a61301ebd6b5cc1df265b9ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a6526e6b9a61301ebd6b5cc1df265b9ee">BaseConnection</a> ()</td></tr>
<tr class="separator:a6526e6b9a61301ebd6b5cc1df265b9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6655f465c3758ccf16762bb29c3924f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a6655f465c3758ccf16762bb29c3924f7">getPreAndPostLayerNames</a> (const char *name, <a class="el" href="classPV_1_1PVParams.html">PVParams</a> *params, char **preLayerNamePtr, char **postLayerNamePtr)</td></tr>
<tr class="separator:a6655f465c3758ccf16762bb29c3924f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af288d6023bba10bc335703cd63d4e8ff"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#af288d6023bba10bc335703cd63d4e8ff">handleMissingPreAndPostLayerNames</a> ()</td></tr>
<tr class="separator:af288d6023bba10bc335703cd63d4e8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a439c2eda66dea4c83fb42135e383e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ac9a439c2eda66dea4c83fb42135e383e">initialize</a> (const char *name, <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *hc)</td></tr>
<tr class="separator:ac9a439c2eda66dea4c83fb42135e383e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac472aa90048c60c453855f1bb86134aa"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ac472aa90048c60c453855f1bb86134aa">ioParamsFillGroup</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="separator:ac472aa90048c60c453855f1bb86134aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fd61a0b40955bb2cb4b5292372a7e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a88fd61a0b40955bb2cb4b5292372a7e8">setChannelType</a> (ChannelType ch)</td></tr>
<tr class="separator:a88fd61a0b40955bb2cb4b5292372a7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16596840aabceadcca9eeeb5509bb1a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a16596840aabceadcca9eeeb5509bb1a2">setConvertRateToSpikeCount</a> (bool convertRateToSpikeCountFlag)</td></tr>
<tr class="separator:a16596840aabceadcca9eeeb5509bb1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383eb2713c08082509f74639ee2f8898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a383eb2713c08082509f74639ee2f8898">setDelay</a> (int arborId, float delay)</td></tr>
<tr class="separator:a383eb2713c08082509f74639ee2f8898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605ab0c6f896a76244f1775551a7dc7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a605ab0c6f896a76244f1775551a7dc7e">setName</a> (const char *name)</td></tr>
<tr class="separator:a605ab0c6f896a76244f1775551a7dc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6be4f8f8e3001a80d63d67a11f5f95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a4f6be4f8f8e3001a80d63d67a11f5f95">setNumberOfAxonalArborLists</a> (int numArbors)</td></tr>
<tr class="separator:a4f6be4f8f8e3001a80d63d67a11f5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d0597598512a94bde243a303997dce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a50d0597598512a94bde243a303997dce">setParent</a> (<a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *hc)</td></tr>
<tr class="separator:a50d0597598512a94bde243a303997dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbea821845660de6aa34d12e8bed21a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a9bbea821845660de6aa34d12e8bed21a">setPostLayerName</a> (const char *postName)</td></tr>
<tr class="separator:a9bbea821845660de6aa34d12e8bed21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdd51256f17d3c3d3e126d38eec5c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#abfdd51256f17d3c3d3e126d38eec5c43">setPostSynapticLayer</a> (<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *post)</td></tr>
<tr class="separator:abfdd51256f17d3c3d3e126d38eec5c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305b16e794769ffa39e2e5557025c7c3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a305b16e794769ffa39e2e5557025c7c3">setPreAndPostLayerNames</a> ()</td></tr>
<tr class="separator:a305b16e794769ffa39e2e5557025c7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5a7a38697c6e7ab61502d44daea61f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#aee5a7a38697c6e7ab61502d44daea61f">setPreLayerName</a> (const char *preName)</td></tr>
<tr class="separator:aee5a7a38697c6e7ab61502d44daea61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ac6677b9533df9fbc991a5788de1c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ac9ac6677b9533df9fbc991a5788de1c1">setPreSynapticLayer</a> (<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *pre)</td></tr>
<tr class="separator:ac9ac6677b9533df9fbc991a5788de1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b67261072e5e282f54ac1e5785fa8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84b67261072e5e282f54ac1e5785fa8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setReceiveGpu</b> ()</td></tr>
<tr class="separator:a84b67261072e5e282f54ac1e5785fa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:afca788ce4dea591c69b75e48097ce611"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#afca788ce4dea591c69b75e48097ce611">inferPreAndPostFromConnName</a> (const char *name, int rank, char **preLayerNamePtr, char **postLayerNamePtr)</td></tr>
<tr class="separator:afca788ce4dea591c69b75e48097ce611"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
BaseConnection Parameters</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2e5c5dc9160e0562c436e5988e0f22a3"></a>List of parameters needed from the <a class="el" href="classPV_1_1BaseConnection.html">BaseConnection</a> class </p>
</td></tr>
<tr class="memitem:a36baac63ad563650145cb6244257311d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36baac63ad563650145cb6244257311d"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:a36baac63ad563650145cb6244257311d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a189b39a328f1335128c383e9cfe40d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a189b39a328f1335128c383e9cfe40d"></a>
<a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parent</b></td></tr>
<tr class="separator:a0a189b39a328f1335128c383e9cfe40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174e35722eaab21cd38eb2908f8903a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a174e35722eaab21cd38eb2908f8903a7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>connId</b></td></tr>
<tr class="separator:a174e35722eaab21cd38eb2908f8903a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0b03dae570319f6831254008fafa05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb0b03dae570319f6831254008fafa05"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>preLayerName</b></td></tr>
<tr class="separator:acb0b03dae570319f6831254008fafa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16807530cf6b6689296abfd2513a7d10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16807530cf6b6689296abfd2513a7d10"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><b>postLayerName</b></td></tr>
<tr class="separator:a16807530cf6b6689296abfd2513a7d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67eb85575bd12f1fc83d41efc0773dab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67eb85575bd12f1fc83d41efc0773dab"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pre</b></td></tr>
<tr class="separator:a67eb85575bd12f1fc83d41efc0773dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795cb74f306f0f67a014c32e1632c066"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a795cb74f306f0f67a014c32e1632c066"></a>
<a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>post</b></td></tr>
<tr class="separator:a795cb74f306f0f67a014c32e1632c066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85bfd842d7406c7a0f2668fdf31fe38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab85bfd842d7406c7a0f2668fdf31fe38"></a>
ChannelType&#160;</td><td class="memItemRight" valign="bottom"><b>channel</b></td></tr>
<tr class="separator:ab85bfd842d7406c7a0f2668fdf31fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d432cd907a0ea9cf0c6a8194e9fb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859d432cd907a0ea9cf0c6a8194e9fb6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numAxonalArborLists</b></td></tr>
<tr class="separator:a859d432cd907a0ea9cf0c6a8194e9fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4695a78d9aa68b33b1a597e1ef167fd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4695a78d9aa68b33b1a597e1ef167fd3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>plasticityFlag</b></td></tr>
<tr class="separator:a4695a78d9aa68b33b1a597e1ef167fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b388826683512d43ec52f6c2f83469"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25b388826683512d43ec52f6c2f83469"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>convertRateToSpikeCount</b></td></tr>
<tr class="separator:a25b388826683512d43ec52f6c2f83469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b5c297a06ad9ecf51e0280f93e89d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73b5c297a06ad9ecf51e0280f93e89d2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>receiveGpu</b></td></tr>
<tr class="separator:a73b5c297a06ad9ecf51e0280f93e89d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b667614aa0a284156e2f3c3e14521e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02b667614aa0a284156e2f3c3e14521e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initializeFromCheckpointFlag</b></td></tr>
<tr class="separator:a02b667614aa0a284156e2f3c3e14521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951a07a28e41920e16ca105ab1ceaba3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a951a07a28e41920e16ca105ab1ceaba3"></a>
<a class="el" href="classPV_1_1BaseConnectionProbe.html">BaseConnectionProbe</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>probes</b></td></tr>
<tr class="separator:a951a07a28e41920e16ca105ab1ceaba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa983cbd4a723721201f2d22a1b0814a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa983cbd4a723721201f2d22a1b0814a0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numProbes</b></td></tr>
<tr class="separator:aa983cbd4a723721201f2d22a1b0814a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426863a787e04966a32a1eeb4205bed4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a426863a787e04966a32a1eeb4205bed4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initInfoCommunicatedFlag</b></td></tr>
<tr class="separator:a426863a787e04966a32a1eeb4205bed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41ef89416d718442dc48a2b024a85a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af41ef89416d718442dc48a2b024a85a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>dataStructuresAllocatedFlag</b></td></tr>
<tr class="separator:af41ef89416d718442dc48a2b024a85a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2de21164586d22332c13aa2fd5116ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2de21164586d22332c13aa2fd5116ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initialValuesSetFlag</b></td></tr>
<tr class="separator:ac2de21164586d22332c13aa2fd5116ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad690218ecc6f2ceebfb1d6b02a8cd0da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad690218ecc6f2ceebfb1d6b02a8cd0da"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>delayArraySize</b></td></tr>
<tr class="separator:ad690218ecc6f2ceebfb1d6b02a8cd0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabebe4d4dfba064e308e7d585e260251"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabebe4d4dfba064e308e7d585e260251"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><b>delays</b></td></tr>
<tr class="separator:aabebe4d4dfba064e308e7d585e260251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffb80e676c2b05ccaffe700adafece6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ffb80e676c2b05ccaffe700adafece6"></a>
float *&#160;</td><td class="memItemRight" valign="bottom"><b>fDelayArray</b></td></tr>
<tr class="separator:a2ffb80e676c2b05ccaffe700adafece6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67faf9e8d0dec06f57c5db4c596f411"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae67faf9e8d0dec06f57c5db4c596f411"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getDelayArraySize</b> ()</td></tr>
<tr class="separator:ae67faf9e8d0dec06f57c5db4c596f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae30bac5b87e27c096e160da7a8b07c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#aae30bac5b87e27c096e160da7a8b07c8">ioParam_preLayerName</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:aae30bac5b87e27c096e160da7a8b07c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">preLayerName: Specifies the connection's pre layer  <a href="#aae30bac5b87e27c096e160da7a8b07c8">More...</a><br /></td></tr>
<tr class="separator:aae30bac5b87e27c096e160da7a8b07c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19364a0244cb16b0025ed2b34a053c12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a19364a0244cb16b0025ed2b34a053c12">ioParam_postLayerName</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a19364a0244cb16b0025ed2b34a053c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">postLayerName: Specifies the connection's post layer  <a href="#a19364a0244cb16b0025ed2b34a053c12">More...</a><br /></td></tr>
<tr class="separator:a19364a0244cb16b0025ed2b34a053c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470df62079c60e62e95fd22004a9adb3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a470df62079c60e62e95fd22004a9adb3">ioParam_channelCode</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a470df62079c60e62e95fd22004a9adb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">channelCode: Specifies which channel in the post layer this connection is attached to  <a href="#a470df62079c60e62e95fd22004a9adb3">More...</a><br /></td></tr>
<tr class="separator:a470df62079c60e62e95fd22004a9adb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad979d27f6d1477c630628323dca3fb12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ad979d27f6d1477c630628323dca3fb12">ioParam_delay</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:ad979d27f6d1477c630628323dca3fb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">delay: Specifies delay(s) which the post layer will receive data  <a href="#ad979d27f6d1477c630628323dca3fb12">More...</a><br /></td></tr>
<tr class="separator:ad979d27f6d1477c630628323dca3fb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b7d91e993091877cc1dc5ab18c488b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8b7d91e993091877cc1dc5ab18c488b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ae8b7d91e993091877cc1dc5ab18c488b">ioParam_numAxonalArbors</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:ae8b7d91e993091877cc1dc5ab18c488b"><td class="mdescLeft">&#160;</td><td class="mdescRight">numAxonalArbors: Specifies the number of arbors to use in this connection <br /></td></tr>
<tr class="separator:ae8b7d91e993091877cc1dc5ab18c488b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1902dddd3f69d3fc46f9ec1a63ee2979"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1902dddd3f69d3fc46f9ec1a63ee2979"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a1902dddd3f69d3fc46f9ec1a63ee2979">ioParam_plasticityFlag</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a1902dddd3f69d3fc46f9ec1a63ee2979"><td class="mdescLeft">&#160;</td><td class="mdescRight">plasticityFlag: Specifies if the weights will update <br /></td></tr>
<tr class="separator:a1902dddd3f69d3fc46f9ec1a63ee2979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11736d629526f3c58299f78265e3a61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#aa11736d629526f3c58299f78265e3a61">ioParam_convertRateToSpikeCount</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:aa11736d629526f3c58299f78265e3a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">preActivityIsNotRate: If true, pre activity is spike rate. If false, pre activity is value  <a href="#aa11736d629526f3c58299f78265e3a61">More...</a><br /></td></tr>
<tr class="separator:aa11736d629526f3c58299f78265e3a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1121921926614fb4af7303fdb91542e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1121921926614fb4af7303fdb91542e6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a1121921926614fb4af7303fdb91542e6">ioParam_receiveGpu</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a1121921926614fb4af7303fdb91542e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">receiveGpu: If true and PetaVision was compiled with GPU acceleration, the connection uses the GPU to update the postsynaptic layer's GSyn. If compiled without GPU acceleration, this flag is ignored. <br /></td></tr>
<tr class="separator:a1121921926614fb4af7303fdb91542e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acb8e53bffb55c4fabaef0ebf88b35f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a6acb8e53bffb55c4fabaef0ebf88b35f">ioParam_initializeFromCheckpointFlag</a> (enum ParamsIOFlag ioFlag)</td></tr>
<tr class="memdesc:a6acb8e53bffb55c4fabaef0ebf88b35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializeFromCheckpointFlag: If set to true, initialize using checkpoint direcgtory set in <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>.  <a href="#a6acb8e53bffb55c4fabaef0ebf88b35f">More...</a><br /></td></tr>
<tr class="separator:a6acb8e53bffb55c4fabaef0ebf88b35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae110837cca7d61443b745992c253778f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ae110837cca7d61443b745992c253778f">getNumProbes</a> ()</td></tr>
<tr class="separator:ae110837cca7d61443b745992c253778f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f3a5e41b57a6d58e1c41e2b2254ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPV_1_1BaseConnectionProbe.html">BaseConnectionProbe</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a33f3a5e41b57a6d58e1c41e2b2254ff9">getProbe</a> (int i)</td></tr>
<tr class="separator:a33f3a5e41b57a6d58e1c41e2b2254ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583611025463b1d6f01069548417f018"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a583611025463b1d6f01069548417f018">readStateFromCheckpoint</a> (const char *cpDir, double *timeptr)=0</td></tr>
<tr class="separator:a583611025463b1d6f01069548417f018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53366232c096004e249317148d8e6be3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a53366232c096004e249317148d8e6be3">setInitialValues</a> ()=0</td></tr>
<tr class="separator:a53366232c096004e249317148d8e6be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2742c810f7fcfc91219f09b3174825"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a6b2742c810f7fcfc91219f09b3174825">needUpdate</a> (double time, double dt)=0</td></tr>
<tr class="separator:a6b2742c810f7fcfc91219f09b3174825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60370ef49a456d96e388a646c55112b8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a60370ef49a456d96e388a646c55112b8">initializeDelays</a> (const float *fDelayArray, int size)</td></tr>
<tr class="separator:a60370ef49a456d96e388a646c55112b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410e18b6bbacafa8f7d98a77ba2dc46e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#a410e18b6bbacafa8f7d98a77ba2dc46e">initialize_base</a> ()</td></tr>
<tr class="separator:a410e18b6bbacafa8f7d98a77ba2dc46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0c77b79042285b7608f7eeb052851a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPV_1_1BaseConnection.html#ade0c77b79042285b7608f7eeb052851a">decodeChannel</a> (int channel_code, ChannelType *channel_type)</td></tr>
<tr class="separator:ade0c77b79042285b7608f7eeb052851a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac3e0a8a65678bfdc6e0467962a6ca4d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PV::BaseConnection::~BaseConnection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor for <a class="el" href="classPV_1_1BaseConnection.html">BaseConnection</a> </p>

</div>
</div>
<a class="anchor" id="a6526e6b9a61301ebd6b5cc1df265b9ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PV::BaseConnection::BaseConnection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor implicitly called by derived classes' constructors. It calls <a class="el" href="classPV_1_1BaseConnection.html#a410e18b6bbacafa8f7d98a77ba2dc46e">initialize_base()</a>, but not <a class="el" href="classPV_1_1BaseConnection.html#ac9a439c2eda66dea4c83fb42135e383e">initialize()</a>.</p>
<p>Note that <a class="el" href="classPV_1_1BaseConnection.html">BaseConnection</a> has no public constructors; only derived classes can be constructed directly. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adb315c18857ef272abbcdb49efec961f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::allocateDataStructures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>allocateDataStructures is used to allocate blocks of memory whose size and arrangement depend on parameters. (For example, <a class="el" href="classPV_1_1HyPerConn.html">HyPerConn</a> allocates weight patches and data patches). After a connection is constructed, it is not properly initialized until <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a>, <a class="el" href="classPV_1_1BaseConnection.html#adb315c18857ef272abbcdb49efec961f">allocateDataStructures()</a>, and <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> have been called.</p>
<p>Return values: PV_POSTPONE means that <a class="el" href="classPV_1_1BaseConnection.html#adb315c18857ef272abbcdb49efec961f">allocateDataStructures()</a> cannot be run until other layers'/connections' own <a class="el" href="classPV_1_1BaseConnection.html#adb315c18857ef272abbcdb49efec961f">allocateDataStructures()</a> have been run successfully.</p>
<p>PV_SUCCESS and PV_FAILURE have their usual meanings.</p>
<p><a class="el" href="classPV_1_1BaseConnection.html#adb315c18857ef272abbcdb49efec961f">allocateDataStructures()</a> is typically called by the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run() method. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1HyPerConn.html#a70d80fdc9041d539a9ff1e171f91640f">PV::HyPerConn</a>, <a class="el" href="classPV_1_1CloneConn.html#a8a149e64b37e36a774f2f12b5863a3f4">PV::CloneConn</a>, <a class="el" href="classPV_1_1OjaSTDPConn.html#a41c8f855d8e45415b59986bf42058229">PV::OjaSTDPConn</a>, <a class="el" href="classPV_1_1LCALIFLateralConn.html#ab5040d077fb78faa3051e1a26e9e3643">PV::LCALIFLateralConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#add2ca550bc8086b4ba7781fa235ae39d">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1ImprintConn.html#ab9ec4d55a7a2fea63397c1f2572e114d">PV::ImprintConn</a>, <a class="el" href="classPV_1_1PoolingConn.html#a88fa9f3bf328518117ae1386b74f04d6">PV::PoolingConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#a8a6976361a181eff756edcc377f78dc2">PV::TransposeConn</a>, <a class="el" href="classPV_1_1MomentumConn.html#a24fe2a1bf489a3ff46237cdc6eda01fe">PV::MomentumConn</a>, <a class="el" href="classPV_1_1privateTransposeConn.html#aa24d265ca399989161b877bab27897f0">PV::privateTransposeConn</a>, and <a class="el" href="classPV_1_1GapConn.html#a19a77f5e893356b2d9c2f24018677ecf">PV::GapConn</a>.</p>

</div>
</div>
<a class="anchor" id="a9cf5f4fb0cc822c4ce25b29e81154f0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PV::BaseConnection::checkpointRead </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>timeptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual function for reading the state of the connection from the directory specified in cpDir. On exit, *timeptr is the time at which the checkpoint was written. <a class="el" href="classPV_1_1BaseConnection.html#a9cf5f4fb0cc822c4ce25b29e81154f0c">checkpointRead()</a> should restore the state of the connection completely, so that restarting from a checkpoint is equivalent to having the run continue. </p>

<p>Implemented in <a class="el" href="classPV_1_1HyPerConn.html#ab6824a17e0ae283ce8042d63a5b65fe8">PV::HyPerConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#ade6959bb0e409d64db71f1273b0b3020">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1OjaSTDPConn.html#a823306deb705bfd6b515b96b5e21177d">PV::OjaSTDPConn</a>, <a class="el" href="classPV_1_1LCALIFLateralConn.html#ae202c4c8c24193497b7afc902180df72">PV::LCALIFLateralConn</a>, <a class="el" href="classPV_1_1CloneConn.html#a00a0478c241ac66ec8aa7f86d5816664">PV::CloneConn</a>, <a class="el" href="classPV_1_1ImprintConn.html#a5257b1cbc2eff50e5a6ae15205203e4c">PV::ImprintConn</a>, <a class="el" href="classPV_1_1MomentumConn.html#a519d82b5950847240b92f6ad4c9845ad">PV::MomentumConn</a>, and <a class="el" href="classPV_1_1PoolingConn.html#af035d9f5bf0d7ee74b280ed2eeac156a">PV::PoolingConn</a>.</p>

</div>
</div>
<a class="anchor" id="a4352bfd2a8b96862c089b7fd1e44771a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PV::BaseConnection::checkpointWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpDir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual function for writing the state of the connection to the directory specified in cpDir. <a class="el" href="classPV_1_1BaseConnection.html#a4352bfd2a8b96862c089b7fd1e44771a">checkpointWrite()</a> should save the complete state of the connection, so that restarting from a checkpoint is equivalent to having the run continue. </p>

<p>Implemented in <a class="el" href="classPV_1_1HyPerConn.html#a0e91da827bf65c6482c2f0750b4e5b04">PV::HyPerConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#aa9ddbf1706582a47593722ba76a9cb79">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1OjaSTDPConn.html#a03efabd17e44f57abcf7e5e1d24df1e4">PV::OjaSTDPConn</a>, <a class="el" href="classPV_1_1LCALIFLateralConn.html#afd85b2c8393c09e8ac18f9f1afca8b33">PV::LCALIFLateralConn</a>, <a class="el" href="classPV_1_1CloneConn.html#a3175839735c7cf21fb1db433f527ad88">PV::CloneConn</a>, <a class="el" href="classPV_1_1ImprintConn.html#ae2ce443cf4cfc00219f9834c19c022d6">PV::ImprintConn</a>, <a class="el" href="classPV_1_1MomentumConn.html#a86e39d86a2d92dc732f020616514ef6a">PV::MomentumConn</a>, and <a class="el" href="classPV_1_1PoolingConn.html#a60cd219f186327b08fec0b2654ffd3f1">PV::PoolingConn</a>.</p>

</div>
</div>
<a class="anchor" id="af9f5e34647332445a73f07ad02aa5868"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::communicateInitInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>communicateInitInfo is used to allow connections and layers to set params and related member variables based on what other layers or connections are doing. (For example, <a class="el" href="classPV_1_1CloneConn.html">CloneConn</a> sets many parameters the same as its originalConn.) After a connection is constructed, it is not properly initialized until <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a>, <a class="el" href="classPV_1_1BaseConnection.html#adb315c18857ef272abbcdb49efec961f">allocateDataStructures()</a>, and <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> have been called.</p>
<p>Return values: PV_POSTPONE means that <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> cannot be run until other layers'/connections' own <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> have been run successfully.</p>
<p>PV_SUCCESS and PV_FAILURE have their usual meanings.</p>
<p><a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> is typically called by the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run() method. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1HyPerConn.html#a18a5cc03609f6d283f62410c7243e019">PV::HyPerConn</a>, <a class="el" href="classPV_1_1OjaSTDPConn.html#a80a809f8995623b3dc192b7c89b2fc80">PV::OjaSTDPConn</a>, <a class="el" href="classPV_1_1LCALIFLateralConn.html#aa469d780ce9ae0f04603c80c2d76c4a8">PV::LCALIFLateralConn</a>, <a class="el" href="classPV_1_1BiLinearConn.html#a6f4a64bdbcd2617c21be012e3bdfa9ed">PV::BiLinearConn</a>, <a class="el" href="classPV_1_1IdentConn.html#a8ab38891828d62979c6444b1e6da49a5">PV::IdentConn</a>, <a class="el" href="classPV_1_1CloneConn.html#a342ec68e74653ca8ef57c458dfc000c4">PV::CloneConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#a0c62972470d72193fb6016322d01e60c">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1PoolingConn.html#a36b22efa5bdc00b50640a6bab277d9b7">PV::PoolingConn</a>, <a class="el" href="classPV_1_1CloneKernelConn.html#a0e9226cff9634838781c3e9b44d41e2c">PV::CloneKernelConn</a>, <a class="el" href="classPV_1_1PlasticCloneConn.html#a8ff66a711a59802a32cbbc522f41c5f0">PV::PlasticCloneConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#aed7999003aa1a2dffb5118ee1b59b5f9">PV::TransposeConn</a>, <a class="el" href="classPV_1_1CopyConn.html#a7cde9de193f5b6c2839e3af747103483">PV::CopyConn</a>, and <a class="el" href="classPV_1_1privateTransposeConn.html#ae14636331de02a1adfa1796d2a567646">PV::privateTransposeConn</a>.</p>

</div>
</div>
<a class="anchor" id="ade0c77b79042285b7608f7eeb052851a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int PV::BaseConnection::decodeChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChannelType *&#160;</td>
          <td class="paramname"><em>channel_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type-safe method of translating an integer channel_code into an allowed channel type. If channel_code corresponds to a recognized channel type, *channel_type is set accordingly and the function returns successfully. Otherwise, *channel_type is undefined and the function returns PV_FAILURE. </p>

</div>
</div>
<a class="anchor" id="ad66445aef165085c3c1532723343892c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PV::BaseConnection::deliver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual function for modifying the post-synaptic layer's GSyn buffer based on the connection and the presynaptic activity </p>

<p>Implemented in <a class="el" href="classPV_1_1HyPerConn.html#a6224b373cdf3ed2945009b05384045e9">PV::HyPerConn</a>, and <a class="el" href="classPV_1_1privateTransposeConn.html#addc16c43ed29179a6e7452e338558c09">PV::privateTransposeConn</a>.</p>

</div>
</div>
<a class="anchor" id="af8c45f692f702a2bbcbcda61ca37dcaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PV::BaseConnection::finalizeUpdate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A virtual function for performing any necessary updates after the normalizers are called. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1HyPerConn.html#a9b52df3960d65adc7ea54cc9d96d1adf">PV::HyPerConn</a>, <a class="el" href="classPV_1_1CloneConn.html#aa7087e1458a2b6b7fc67defd6be181a6">PV::CloneConn</a>, <a class="el" href="classPV_1_1PoolingConn.html#a82129c432c8d903890ba1f31e91df4b3">PV::PoolingConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#a58c51b44117bebea00bde177d89a870b">PV::TransposeConn</a>, and <a class="el" href="classPV_1_1privateTransposeConn.html#a9c752c152e410993612e9b6d3fad9b68">PV::privateTransposeConn</a>.</p>

</div>
</div>
<a class="anchor" id="a4be0fa26cb77eeb9639fe050a321d94e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::getConnectionId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the connection's connId (assigned when added to its parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>) </p>

</div>
</div>
<a class="anchor" id="a4156c5a76ca32f25d7c2ed3b2b4d18ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PV::BaseConnection::getConvertRateToSpikeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the connection treats pre-synaptic activity as a not-rate. Returns false if the connection treats pre-synaptic activity as a rate. </p>

</div>
</div>
<a class="anchor" id="a9347ed2d5346fede4e490351926b5da5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PV::BaseConnection::getDataStructuresAllocatedFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true or false, depending on whether <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> has been called successfully. </p>

</div>
</div>
<a class="anchor" id="afe70c6d11aa83fd6c5a5c0c3bda73e72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::getDelay </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arbor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the delay (in timesteps) belonging the given arbor. </p>

</div>
</div>
<a class="anchor" id="a764a2087e925f175e24bd144f4c9c062"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PV::BaseConnection::getInitialValuesSetFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true or false, depending on whether <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> has been called successfully. </p>

</div>
</div>
<a class="anchor" id="ad617960920014f253c2244a915ce5543"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PV::BaseConnection::getInitInfoCommunicatedFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true or false, depending on whether <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> has been called successfully. </p>

</div>
</div>
<a class="anchor" id="a829c6e9c1ea72edce9c41992c295703e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* PV::BaseConnection::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the connection's name </p>

</div>
</div>
<a class="anchor" id="ae110837cca7d61443b745992c253778f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::getNumProbes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of probes that have been attached to this connection </p>

</div>
</div>
<a class="anchor" id="aba4b40893e9e1285c43cd407d4958bc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>* PV::BaseConnection::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the connection's parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>. </p>

</div>
</div>
<a class="anchor" id="a6655f465c3758ccf16762bb29c3924f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::getPreAndPostLayerNames </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPV_1_1PVParams.html">PVParams</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>preLayerNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>postLayerNamePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets *preLayerNamePtr and *postLayerNamePtr according to the preLayerName and postLayerName parameters in the parameter group specified by the name and params arguments. </p>

</div>
</div>
<a class="anchor" id="a33f3a5e41b57a6d58e1c41e2b2254ff9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPV_1_1BaseConnectionProbe.html">BaseConnectionProbe</a>* PV::BaseConnection::getProbe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the probe with the indicated position in the list of probes. It does not do sanity checking on the value of i. </p>

</div>
</div>
<a class="anchor" id="af288d6023bba10bc335703cd63d4e8ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::handleMissingPreAndPostLayerNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">BaseConnection::communicateInitInfo</a> of the params did not set pre- and post- layers. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1FeedbackConn.html#adc5317085f1686eba0f710823e82a044">PV::FeedbackConn</a>.</p>

</div>
</div>
<a class="anchor" id="afca788ce4dea591c69b75e48097ce611"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::inferPreAndPostFromConnName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>preLayerNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>postLayerNamePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default behavior of <a class="el" href="classPV_1_1BaseConnection.html#af288d6023bba10bc335703cd63d4e8ff">BaseConnection::handleMissingPreAndPostLayerNames</a>. It tries to parse the name argument of the connection in the form "PreLayerToPostLayer". Then "PreLayer" put into *preLayerNamePtr and "PostLayer" is put into *postLayerNamePtr, and PV_SUCCESS is returned. If name does not contain the string "To", or if it contains it in more than one place, then PV_FAILURE is returned and *preLayerNamePtr and *postLayerNamePtr are not changed. rank is the rank of the process under MPI; the root process will print a message to stderr if the routine fails; non-root process will not. This routine uses malloc to fill *{pre,post}LayerNamePtr, so the routine calling this one is responsible for freeing them. </p>

</div>
</div>
<a class="anchor" id="ac9a439c2eda66dea4c83fb42135e383e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::initialize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *&#160;</td>
          <td class="paramname"><em>hc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The initialization routine. It should be called during the initialization routine of any derived class.</p>
<p>It sets the name and parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> to the indicated arguments, and calls (via ioParams) the virtual ioParamsFillGroup method, which reads params from the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s params. </p>

</div>
</div>
<a class="anchor" id="a410e18b6bbacafa8f7d98a77ba2dc46e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::initialize_base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by the constructor, <a class="el" href="classPV_1_1BaseConnection.html#a410e18b6bbacafa8f7d98a77ba2dc46e">initialize_base()</a> sets member variables to safe values (e.g. pointers to NULL) and parameters to default values. </p>

</div>
</div>
<a class="anchor" id="a60370ef49a456d96e388a646c55112b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::initializeDelays </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>fDelayArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates the delays array and calls <a class="el" href="classPV_1_1BaseConnection.html#a383eb2713c08082509f74639ee2f8898">setDelay()</a> for each arbor. fDelayArray is an array of length size, of delays, measured in the same units as the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s dt.</p>
<p>If size=0, all delays are set to zero. If size=1, all delays are set to fDelayArray[0] If size=numArbors, delays[k] is calculated from fDelayArray[k]. If size is any other value, it is an error. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1privateTransposeConn.html#a30871d6e99b2ac4b448916a75280dc45">PV::privateTransposeConn</a>.</p>

</div>
</div>
<a class="anchor" id="a556aa9907b6bd34efb829825fb4d96cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::initializeState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>initializeState is used to set the initial values of the connection. If the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s checkpointReadFlag is set, it calls <a class="el" href="classPV_1_1BaseConnection.html#a9cf5f4fb0cc822c4ce25b29e81154f0c">checkpointRead()</a> If not, but the connection's initializeFromCheckpointFlag is set, it calls <a class="el" href="classPV_1_1BaseConnection.html#a583611025463b1d6f01069548417f018">readStateFromCheckpoint()</a>. If neither of these flags is set, it calls setInitialValues. Note that derived classes must implement the methods <a class="el" href="classPV_1_1BaseConnection.html#a9cf5f4fb0cc822c4ce25b29e81154f0c">checkpointRead()</a>, <a class="el" href="classPV_1_1BaseConnection.html#a583611025463b1d6f01069548417f018">readStateFromCheckpoint()</a>, and <a class="el" href="classPV_1_1BaseConnection.html#a53366232c096004e249317148d8e6be3">setInitialValues()</a>.</p>
<p>After a connection is constructed, it is not properly initialized until <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a>, <a class="el" href="classPV_1_1BaseConnection.html#adb315c18857ef272abbcdb49efec961f">allocateDataStructures()</a>, and <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> have been called.</p>
<p>Return values: PV_POSTPONE means that <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> cannot be run until other layers'/connections' own <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> have been run successfully.</p>
<p>PV_SUCCESS and PV_FAILURE have their usual meanings.</p>
<p><a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">initializeState()</a> is typically called by the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run() method. </p>

</div>
</div>
<a class="anchor" id="ab45f5d3470934a92139919ca17ff4409"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::insertProbe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPV_1_1BaseConnectionProbe.html">BaseConnectionProbe</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the given probe to the list of probes. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1HyPerConn.html#afc3e8145f1b9e1210935aeb4732c1df6">PV::HyPerConn</a>.</p>

</div>
</div>
<a class="anchor" id="a470df62079c60e62e95fd22004a9adb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::ioParam_channelCode </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>channelCode: Specifies which channel in the post layer this connection is attached to </p>
<p>Channels can be -1 for no update, or &gt;= 0 for channel number. <br />
 0 is excitatory, 1 is inhibitory </p>

<p>Reimplemented in <a class="el" href="classPV_1_1HyPerConn.html#a40deeb8556de00595f6479bf2a5bb18d">PV::HyPerConn</a>, and <a class="el" href="classPV_1_1GapConn.html#afd79207b0ea5d9c34a823a863d7384ec">PV::GapConn</a>.</p>

</div>
</div>
<a class="anchor" id="aa11736d629526f3c58299f78265e3a61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::ioParam_convertRateToSpikeCount </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>preActivityIsNotRate: If true, pre activity is spike rate. If false, pre activity is value </p>
<p>The post synaptic layer needs to interpret pre synaptic activity as a spike rate Other situations interpret as a value. This flag sets either one or the other. convertRateToSpikeCount: If true, presynaptic activity should be converted from a rate to a count.</p>
<p>If this flag is true and the presynaptic layer is not spiking, the activity will be interpreted as a spike rate, and will be converted to a spike count when delivering activity to the postsynaptic GSyn buffer. If this flag is false, activity will not be converted. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1IdentConn.html#aec0beb0c363d9ee1126e28dcc0fd5275">PV::IdentConn</a>.</p>

</div>
</div>
<a class="anchor" id="ad979d27f6d1477c630628323dca3fb12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::ioParam_delay </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delay: Specifies delay(s) which the post layer will receive data </p>
<p>: Delays are specified in units of dt, but are rounded to be integer multiples of dt. If delay is a scalar, all arbors of the connection have that value of delay. If delay is an array, the length must match the number of arbors and the arbors are assigned the delays sequentially. </p>

</div>
</div>
<a class="anchor" id="a6acb8e53bffb55c4fabaef0ebf88b35f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::ioParam_initializeFromCheckpointFlag </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initializeFromCheckpointFlag: If set to true, initialize using checkpoint direcgtory set in <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>. </p>
<p>Checkpoint read directory must be set in <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> to initialize from checkpoint. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1CloneConn.html#a3825eb293f2119d5505fc83a24ebd628">PV::CloneConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#a590d09b5f87450984c79ab1def005a66">PV::TransposeConn</a>, <a class="el" href="classPV_1_1CopyConn.html#a42dc009b8395749f0b2326f9096e2172">PV::CopyConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#a9c24552de51130c70070cd159c8c89e7">PV::TransposePoolingConn</a>, and <a class="el" href="classPV_1_1IdentConn.html#a619f30bbde13e36764b2961348886fdf">PV::IdentConn</a>.</p>

</div>
</div>
<a class="anchor" id="a19364a0244cb16b0025ed2b34a053c12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::ioParam_postLayerName </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>postLayerName: Specifies the connection's post layer </p>
<p>Required parameter </p>

<p>Reimplemented in <a class="el" href="classPV_1_1FeedbackConn.html#ae270a2ef4b7534cc87ecea090b78a10f">PV::FeedbackConn</a>.</p>

</div>
</div>
<a class="anchor" id="aae30bac5b87e27c096e160da7a8b07c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::ioParam_preLayerName </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>preLayerName: Specifies the connection's pre layer </p>
<p>Required parameter </p>

<p>Reimplemented in <a class="el" href="classPV_1_1FeedbackConn.html#aa8edaf330276653b74ab686973c48efc">PV::FeedbackConn</a>.</p>

</div>
</div>
<a class="anchor" id="acdcc2c5884ce0776d49e41767ef45797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::ioParams </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method for reading or writing the params from group in the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s parameters. The group from params is selected using the name of the connection.</p>
<p>Note that ioParams is not virtual. To add parameters in a derived class, override ioParamFillGroup. </p>

</div>
</div>
<a class="anchor" id="ac472aa90048c60c453855f1bb86134aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::ioParamsFillGroup </td>
          <td>(</td>
          <td class="paramtype">enum ParamsIOFlag&#160;</td>
          <td class="paramname"><em>ioFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The virtual method for reading parameters from the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s parameters, and writing to the output params file.</p>
<p><a class="el" href="classPV_1_1BaseConnection.html#ac472aa90048c60c453855f1bb86134aa">BaseConnection::ioParamsFillGroup</a> reads/writes the paremeters preLayerName, postLayerName, channelCode, delay, numAxonalArbors, and convertRateToSpikeCount.</p>
<p>Derived classes with additional parameters typically override ioParamsFillGroup to call the base class's ioParamsFillGroup method and then call ioParam_[parametername] for each of their parameters. The ioParam_[parametername] methods should call the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s ioParamValue() and related methods, to ensure that all parameters that get read also get written to the outputParams-generated file. </p>

<p>Reimplemented in <a class="el" href="classPV_1_1HyPerConn.html#a9d25459925dab07306be9603617c5026">PV::HyPerConn</a>, <a class="el" href="classPV_1_1CloneConn.html#abc7d318d8d6ac58919139eb9f7a44389">PV::CloneConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#afac07fdbe369995d34cc8fc9c3d30be9">PV::TransposeConn</a>, <a class="el" href="classPV_1_1OjaSTDPConn.html#ac4fc342e134c6a59e1c882cded6d6ae1">PV::OjaSTDPConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#ae44db8c5aa352600f4a90a3eaf6fd089">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1LCALIFLateralConn.html#afccdca7b4d880db7eb4bd921923fa85b">PV::LCALIFLateralConn</a>, <a class="el" href="classPV_1_1PoolingConn.html#a256afdd1237cb219dba06c72bca4611e">PV::PoolingConn</a>, <a class="el" href="classPV_1_1IdentConn.html#a0c8914ac14fdceb9906c6ee7e050f4dd">PV::IdentConn</a>, <a class="el" href="classPV_1_1privateTransposeConn.html#a628815de4d28875925a6678997220139">PV::privateTransposeConn</a>, <a class="el" href="classPV_1_1ImprintConn.html#a9ab1db3a961dab411b23c233e8d6aa86">PV::ImprintConn</a>, <a class="el" href="classPV_1_1BiLinearConn.html#a682fef88bd52c6713620d95fa9d180cc">PV::BiLinearConn</a>, <a class="el" href="classPV_1_1CopyConn.html#a9b5a2e93a3d439cf056305b8419fa10a">PV::CopyConn</a>, <a class="el" href="classPV_1_1MomentumConn.html#a715d56e355d487da5e904f8156cee289">PV::MomentumConn</a>, and <a class="el" href="classPV_1_1PlasticCloneConn.html#a69ec887611d82e061aa7db2d554ef376">PV::PlasticCloneConn</a>.</p>

</div>
</div>
<a class="anchor" id="a6b2742c810f7fcfc91219f09b3174825"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PV::BaseConnection::needUpdate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual method whose implementation returns true if an the weights should update on the given timestep and false if not. </p>

<p>Implemented in <a class="el" href="classPV_1_1HyPerConn.html#ab1a574b1184f310e9e0f16f1ccf4ce0a">PV::HyPerConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#a2cbbaecaca94f777bb92157f4ce446eb">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#ab2308dc6eb9dfcb61b420db3b78acf01">PV::TransposeConn</a>, <a class="el" href="classPV_1_1privateTransposeConn.html#aaefa7416f94ec97b719277234c8932e8">PV::privateTransposeConn</a>, and <a class="el" href="classPV_1_1CopyConn.html#ad1d8245d415fe17f3e192350aae603a8">PV::CopyConn</a>.</p>

</div>
</div>
<a class="anchor" id="a663d09deb4f978c513ac5e4b6b8dbc89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::outputProbeParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by HyPerCol::outputParams to output the params groups for probes whose ownership has been transferred to this connection. (Does this need to be virtual?) </p>

<p>Reimplemented in <a class="el" href="classPV_1_1HyPerConn.html#a62fb1e130c43fed1d4104aa85ce3fb58">PV::HyPerConn</a>.</p>

</div>
</div>
<a class="anchor" id="ad53c07d17427ba6ce9c4a29cc6b7e9bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PV::BaseConnection::outputState </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>last</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual function for writing the state of the connection to file(s) in the output directory. For example, <a class="el" href="classPV_1_1HyPerConn.html">HyPerConn</a> writes the weights to a .pvp file with a schedule defined by writeStep and initialWriteTime. </p>

<p>Implemented in <a class="el" href="classPV_1_1HyPerConn.html#a52fbf973234d44386f383062e7968cb2">PV::HyPerConn</a>, <a class="el" href="classPV_1_1OjaSTDPConn.html#a05a2ff7038cc8ba35569d9d99f3afcdd">PV::OjaSTDPConn</a>, and <a class="el" href="classPV_1_1LCALIFLateralConn.html#a2a487d733a51ebf3ad0cd25f563e78c7">PV::LCALIFLateralConn</a>.</p>

</div>
</div>
<a class="anchor" id="a583611025463b1d6f01069548417f018"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PV::BaseConnection::readStateFromCheckpoint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>timeptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual method that uses an existing checkpoint to initialize the connection. <a class="el" href="classPV_1_1BaseConnection.html#a556aa9907b6bd34efb829825fb4d96cd">BaseConnection::initializeState</a> calls it when initializeFromCheckpointFlag is true. A Subclass may also call this method as part of the implementation of checkpointRead (for example, <a class="el" href="classPV_1_1HyPerConn.html">HyPerConn</a> does this). </p>

<p>Implemented in <a class="el" href="classPV_1_1HyPerConn.html#a5672b85261f505ab757e8c54ffc1bef1">PV::HyPerConn</a>, and <a class="el" href="classPV_1_1CloneConn.html#a2682fb7e89128cd03e0706fead4ca72b">PV::CloneConn</a>.</p>

</div>
</div>
<a class="anchor" id="a88fd61a0b40955bb2cb4b5292372a7e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setChannelType </td>
          <td>(</td>
          <td class="paramtype">ChannelType&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the channel to the indicated argument. It is an error to try to change channels after <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> has completed successfully. </p>

</div>
</div>
<a class="anchor" id="a16596840aabceadcca9eeeb5509bb1a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setConvertRateToSpikeCount </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>convertRateToSpikeCountFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the preActivityIsNotRate flag to the indicated argument. It is an error to try to change preActivityIsNotRate after <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> has completed successfully. </p>

</div>
</div>
<a class="anchor" id="a63f62714f2f1410c51bcdd4fe2214920"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setDataStructuresAllocatedFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets the flag returned by <a class="el" href="classPV_1_1BaseConnection.html#a9347ed2d5346fede4e490351926b5da5">getDataStructuresAllocatedFlag()</a> to true. It is public so that the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run method can set it after receiving a successful allocateDataStructures command (this behavior should probably be changed so that BaseConnection::allocateDataStructuresWrapper, not the calling routine, is responsible for setting the flag). </p>

</div>
</div>
<a class="anchor" id="a383eb2713c08082509f74639ee2f8898"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setDelay </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arborId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the delay of the given arbor to the given amount. delay is specified in the same units that the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s dt parameter is specified in. Internally, the delay is set as an integral number of timesteps, specifically round(delay/dt). </p>

</div>
</div>
<a class="anchor" id="a53366232c096004e249317148d8e6be3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PV::BaseConnection::setInitialValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual method for initializing the connection if we are neither restarting from a checkpoint or initializing the connection from a checkpoint. It should return PV_SUCCESS if successful, or PV_POSTPONE if it needs to wait for other objects to set their initial values before it can set its own initial values. (e.g. <a class="el" href="classPV_1_1TransposeConn.html">TransposeConn</a> has to wait for original conn) </p>

<p>Implemented in <a class="el" href="classPV_1_1HyPerConn.html#a7131cc61ed6ee2101feb720f271a01b8">PV::HyPerConn</a>, <a class="el" href="classPV_1_1CopyConn.html#a1a28b9879c7322789371f39cfda19697">PV::CopyConn</a>, <a class="el" href="classPV_1_1TransposeConn.html#a7078d6bac3f7b518834e0176445d6dd8">PV::TransposeConn</a>, <a class="el" href="classPV_1_1TransposePoolingConn.html#ad2c7a173c0ddda5636a5e54a4ed16c37">PV::TransposePoolingConn</a>, <a class="el" href="classPV_1_1PoolingConn.html#a58c8dea49a6acc007455bb06145f0e52">PV::PoolingConn</a>, and <a class="el" href="classPV_1_1privateTransposeConn.html#ab4adde48be8cdc8bb6dbef308c4dee91">PV::privateTransposeConn</a>.</p>

</div>
</div>
<a class="anchor" id="a3f94f2c5bc97b5c5a9697aff6bf83355"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setInitialValuesSetFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets the flag returned by <a class="el" href="classPV_1_1BaseConnection.html#a764a2087e925f175e24bd144f4c9c062">getInitialValuesSetFlag()</a> to true. It is public so that the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run method can set it after receiving a successful initializeState command (this behavior should probably be changed so that BaseConnection::allocateDataStructuresWrapper, not the calling routine, is responsible for setting the flag). </p>

</div>
</div>
<a class="anchor" id="afcf50b01e3b0260d971801edafcbb3e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setInitInfoCommunicatedFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets the flag returned by <a class="el" href="classPV_1_1BaseConnection.html#ad617960920014f253c2244a915ce5543">getInitInfoCommunicatedFlag()</a> to true. It is public so that the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s run method can set it after receiving a successful communicateInitInfo command (this behavior should probably be changed so that BaseConnection::communicateInitInfoWrapper, not the calling routine, is responsible for setting the flag). </p>

</div>
</div>
<a class="anchor" id="a605ab0c6f896a76244f1775551a7dc7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::setName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the name member variable. It should be called after setParent since it uses the parent's columnId() to print any error messages </p>

</div>
</div>
<a class="anchor" id="a4f6be4f8f8e3001a80d63d67a11f5f95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setNumberOfAxonalArborLists </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numArbors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the number of arbors to the indicated argument. It is an error to try to change numArbors after <a class="el" href="classPV_1_1BaseConnection.html#af9f5e34647332445a73f07ad02aa5868">communicateInitInfo()</a> has completed successfully. </p>

</div>
</div>
<a class="anchor" id="a50d0597598512a94bde243a303997dce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a> *&#160;</td>
          <td class="paramname"><em>hc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the parent member variable. </p>

</div>
</div>
<a class="anchor" id="a9bbea821845660de6aa34d12e8bed21a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setPostLayerName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>postName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the postsynaptic layer name to the given string. It is an error to try to set postLayerName after it has already been set, or to call <a class="el" href="classPV_1_1BaseConnection.html#a9bbea821845660de6aa34d12e8bed21a">setPostLayerName()</a> with a NULL argument. </p>

</div>
</div>
<a class="anchor" id="abfdd51256f17d3c3d3e126d38eec5c43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setPostSynapticLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td>
          <td class="paramname"><em>post</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the postsynaptic layer to the given layer. It is an error to try to set postLayer after it has already been set, or to call <a class="el" href="classPV_1_1BaseConnection.html#a9bbea821845660de6aa34d12e8bed21a">setPostLayerName()</a> with a NULL argument. </p>

</div>
</div>
<a class="anchor" id="a305b16e794769ffa39e2e5557025c7c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PV::BaseConnection::setPreAndPostLayerNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the pre- and post-synaptic layer names according to the parent <a class="el" href="classPV_1_1HyPerCol.html">HyPerCol</a>'s params. Virtual to allow subclasses to infer layer names in other ways (for example, <a class="el" href="classPV_1_1FeedbackConn.html">FeedbackConn</a> flips pre- and post- layers from originalConn). </p>

<p>Reimplemented in <a class="el" href="classPV_1_1FeedbackConn.html#ae52a08c9da0edf8458ceaf624f6578c8">PV::FeedbackConn</a>.</p>

</div>
</div>
<a class="anchor" id="aee5a7a38697c6e7ab61502d44daea61f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setPreLayerName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>preName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the presynaptic layer name to the given string. It is an error to try to set preLayerName after it has already been set, or to call <a class="el" href="classPV_1_1BaseConnection.html#aee5a7a38697c6e7ab61502d44daea61f">setPreLayerName()</a> with a NULL argument. </p>

</div>
</div>
<a class="anchor" id="ac9ac6677b9533df9fbc991a5788de1c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PV::BaseConnection::setPreSynapticLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPV_1_1HyPerLayer.html">HyPerLayer</a> *&#160;</td>
          <td class="paramname"><em>pre</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the presynaptic layer to the given layer. It is an error to try to set preLayer after it has already been set, or to call <a class="el" href="classPV_1_1BaseConnection.html#aee5a7a38697c6e7ab61502d44daea61f">setPreLayerName()</a> with a NULL argument. </p>

</div>
</div>
<a class="anchor" id="a25c05fd9460b34359571fde2f83eb4a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PV::BaseConnection::updateStateWrapper </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual function for updating the state of the connection. timed is simulation time, and dt is the time increment between steps. </p>

<p>Implemented in <a class="el" href="classPV_1_1HyPerConn.html#adfb44e745059789fdd528880bcdf64fd">PV::HyPerConn</a>.</p>

</div>
</div>
<a class="anchor" id="adf4a1a8ae010fdaa5b3c4b507965a021"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int PV::BaseConnection::writeTimers </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pure virtual function for writing timing information. </p>

<p>Implemented in <a class="el" href="classPV_1_1HyPerConn.html#a7c5dd9cf14ed977776b25eabd71ee388">PV::HyPerConn</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/bbroompeltz/Documents/PVWebsite/core/pv-core/src/connections/<a class="el" href="BaseConnection_8hpp_source.html">BaseConnection.hpp</a></li>
<li>/Users/bbroompeltz/Documents/PVWebsite/core/pv-core/src/connections/BaseConnection.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>PV</b></li><li class="navelem"><a class="el" href="classPV_1_1BaseConnection.html">BaseConnection</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
