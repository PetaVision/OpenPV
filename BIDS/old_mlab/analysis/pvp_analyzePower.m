function [power_array] = ...
      pvp_analyzePower(layer, ...
		       epoch_struct, ...
		       layer_struct, ...
		       xcorr_struct, ...
		       power_array)

  global BIN_STEP_SIZE DELTA_T
  global pvp_order

  %% init power array
  power_array{layer,1} = zeros(1, layer_struct.num_neurons(layer));
  power_array{layer,2} = zeros(1, layer_struct.num_neurons(layer));

  %% start loop over epochs
  for i_epoch = 1 : epoch_struct.num_epochs
    disp(['i_epoch = ', num2str(i_epoch)]);
    
    %% read spike train for this epoch
    [spike_array] = ...
        pvp_readSparseSpikes(layer, ...
			     i_epoch, ...
			     epoch_struct, ...
			     layer_struct, ...
			     pvp_order);
    if isempty(spike_array)
      continue;
    endif %%
    
    %%accumulate power
    disp([layer_struct.layerID{layer}, ...
          ' ', 'mass_power', ...
          '(', ...
            num2str(layer), ',', num2str(i_epoch), ')']);
    layer_ndx = [1:layer_struct.num_neurons(layer)];
    if xcorr_struct.power_method == 0
      [power_array_tmp, ...
       mass_autocorr_tmp] = ...
          pvp_autocorr(layer, ...
                       layer_ndx, ...
		       epoch_struct, ...
		       xcorr_struct, ...
		       spike_array);
    elseif xcorr_struct.power_method == 1
      [power_array_tmp, ...
       mass_power_tmp] = ...
          pvp_power(layer, ...
                    layer_ndx, ...
		    epoch_struct, ...
		    xcorr_struct, ...
		    spike_array);
    endif %%  % power_method
    power_array{layer, 1} = power_array{layer, 1} + ...
        power_array_tmp(:,1).';
    power_array{layer, 2} = power_array{layer, 2} + ...
        power_array_tmp(:,2).';
    
  endfor %% % i_epoch



