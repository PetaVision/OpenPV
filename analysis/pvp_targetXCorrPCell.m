function ...
      [mass_target_xcorr, ...
       mass_target_autocorr, ...
       mass_clutter_xcorr, ...
       mass_clutter_autocorr, ...
       mass_target2clutter_xcorr, ...
       mass_target2clutter_autocorr] = ...
      pvp_targetXCorrPCell(layer, ...
			   epoch_struct, ...
			   layer_struct, ...
			   target_struct, ...
			   xcorr_struct, ... 
			   mass_target_xcorr, ...
			   mass_target_autocorr, ...
			   mass_clutter_xcorr, ...
			   mass_clutter_autocorr, ...
			   mass_target2clutter_xcorr, ...
			   mass_target2clutter_autocorr)

  global BIN_STEP_SIZE DELTA_T
  global pvp_order
  global NUM_PROCS 

  stim_steps = ...
      epoch_struct.stim_begin_step(layer) : epoch_struct.stim_end_step(layer);
  stim_bins = ...
      epoch_struct.stim_begin_bin(layer) : epoch_struct.stim_end_bin(layer);
  xcorr_flag = 0;

  %% init data structures
  for i_target = 1 : target_struct.num_targets
    mass_target_xcorr{i_target, layer} = ...
	zeros( 2 * xcorr_struct.max_lag + 1, 1 );
    mass_target_autocorr{i_target, layer} = ...
	zeros( 2 * xcorr_struct.max_lag + 1, 1 );
				# target_xcorr{i_target, layer}  = ...
				# 	zeros(target_struct.num_target_neurons_max(layer, i_target),  ...
				#           target_struct.num_target_neurons_max(layer, i_target), 2 );
  endfor %%

  i_target = 1;
  mass_clutter_xcorr{i_target, layer} = ...
      zeros( 2 * xcorr_struct.max_lag + 1, 1 );
  mass_clutter_autocorr{i_target, layer} = ...
      zeros( 2 * xcorr_struct.max_lag + 1, 1 );
				# clutter_xcorr{i_target, layer}  = ...
				#     zeros(target_struct.num_clutter_neurons_max(layer, i_target),  ...
				#           target_struct.num_clutter_neurons_max(layer, i_target), 2 );

  for i_target = 1 : target_struct.num_targets
    mass_target2clutter_xcorr{i_target, layer} = ...
	zeros( 2 * xcorr_struct.max_lag + 1, 1 );
    mass_target2clutter_autocorr{i_target, layer} = ...
	zeros( 2 * xcorr_struct.max_lag + 1, 1 );
				# target2clutter_xcorr{i_target, 1} = ...
				# 	zeros(target_struct.num_target_neurons_max(layer, i_target),  ...
				#           target_struct.num_clutter_neurons_max(layer, 1), 2 );
  endfor %%

  %% start loop over epochs
  for i_epoch = 1 : epoch_struct.num_epochs
    disp(['i_epoch = ', num2str(i_epoch)]);
    
    %% read spike train for this epoch
    [spike_array] = ...
        pvp_readSparseSpikes(layer, ...
			     i_epoch, ...
			     epoch_struct, ...
			     layer_struct, ...
			     pvp_order);
    if isempty(spike_array)
      continue;
    endif %%


    %% target xcorr
    is_auto = 1;
    for i_target = 1 : target_struct.num_targets

      %% set up cell arrays for parcellfun
      %%disp(["setting up parcellfun"]);
      target_ndx_tmp = ...
	  target_struct.target_ndx_max{layer, i_target};
      num_target_neurons_tmp = ...
	  target_struct.num_target_neurons_max(layer, i_target);
      num_per_proc = num_target_neurons_tmp / NUM_PROCS;
      pcell_ndx = cell(NUM_PROCS, 1);
      pcell_first = 1;
      pcell_last = round(num_per_proc);
      for i_pcell = 1 : NUM_PROCS
	pcell_first = 1 + round( num_per_proc * ( i_pcell - 1 ) );
	pcell_first = pcell_first + (pcell_first == pcell_last);
	pcell_last = round( num_per_proc * i_pcell );
	pcell_ndx{i_pcell, 1} = ...
	    target_ndx_tmp(pcell_first:pcell_last);
      endfor
      xcorr_struct_tmp = xcorr_struct;
      xcorr_struct = struct;
      xcorr_struct.max_lag = xcorr_struct_tmp.max_lag;
      xcorr_struct.min_freq_ndx = xcorr_struct_tmp.min_freq_ndx;
      xcorr_struct.max_freq_ndx = xcorr_struct_tmp.max_freq_ndx;

      pcell_pre_train = cell(NUM_PROCS);
      pcell_post_train = cell(NUM_PROCS);
      pcell_xcorr_struct = cell(NUM_PROCS);
      pcell_pre_ndx = cell(NUM_PROCS);
      pcell_size_pre = cell(NUM_PROCS);
      pcell_post_ndx = cell(NUM_PROCS);
      pcell_size_post = cell(NUM_PROCS);
      pcell_is_auto = cell(NUM_PROCS);
      pcell_xcorr_flag = cell(NUM_PROCS);      
      for pre_pcell = 1 : NUM_PROCS
	for post_pcell = 1 : NUM_PROCS
	  pcell_pre_train{pre_pcell, post_pcell} = ...
	      spike_array(stim_steps, ...
			  pcell_ndx{pre_pcell, 1});
	  pcell_post_train{pre_pcell, post_pcell} = ...
	      spike_array(stim_steps, ...
			  pcell_ndx{post_pcell, 1});
	  pcell_xcorr_struct{pre_pcell, post_pcell} = ...
	      xcorr_struct;
	  pcell_pre_ndx{pre_pcell, post_pcell} = ...
	      pcell_ndx{pre_pcell, 1};
	  pcell_size_pre{pre_pcell, post_pcell} = ...
	      layer_struct.size_layer{layer};
	  pcell_post_ndx{pre_pcell, post_pcell} = ...
	      pcell_ndx{post_pcell, 1};
	  pcell_size_post{pre_pcell, post_pcell} = ...
	      layer_struct.size_layer{layer};
	  pcell_is_auto{pre_pcell, post_pcell} = ...
	      is_auto && (pre_pcell == post_pcell);
	  pcell_xcorr_flag{pre_pcell, post_pcell} = ...
	      xcorr_flag;
	endfor
      endfor
      xcorr_struct = xcorr_struct_tmp;
      
      %% execute pvp_xcorr2 in parallel using parcellfun
      debug_flag = 0;
      if debug_flag
	disp(["calling parcellfun @pvp_xcorr2"]);
	disp(["size(pcell_pre_train) = ", num2str(size(pcell_pre_train))]);
	disp(["size(pcell_post_train) = ", num2str(size(pcell_post_train))]);
	disp(["size(pcell_xcorr_struct) = ", num2str(size(pcell_xcorr_struct))]);
	disp(["size(pcell_pre_ndx) = ", num2str(size(pcell_pre_ndx))]);
	disp(["size(pcell_size_pre) = ", num2str(size(pcell_size_pre))]);
	disp(["size(pcell_post_ndx) = ", num2str(size(pcell_post_ndx))]);
	disp(["size(pcell_size_post) = ", num2str(size(pcell_size_post))]);
	disp(["size(pcell_is_auto) = ", num2str(size(pcell_is_auto))]);
	disp(["size(pcell_xcorr_flag) = ", num2str(size(pcell_xcorr_flag))]);
	[error_common_size, common_size_args] = ...
	    common_size(pcell_pre_train, ...
			pcell_post_train, ...
			pcell_xcorr_struct, ...
			pcell_pre_ndx, ...
			pcell_size_pre, ...
			pcell_post_ndx, ...
			pcell_size_post, ...
			pcell_is_auto, ...
			pcell_xcorr_flag);
	disp(["error_common_size = ", num2str(error_common_size)]);
      endif

      test_parcellfun = 0;
      if test_parcellfun
	for pre_pcell = 1 : NUM_PROCS
	  for post_pcell = 1 : NUM_PROCS
	    [pcell_mass_xcorr{pre_pcell, post_pcell}, ...
	     pcell_mass_autocorr{pre_pcell, post_pcell}, ...
	     pcell_mass_xcorr_mean, ...
	     pcell_mass_xcorr_std] = ...
		feval(@pvp_xcorr2, ...
		      pcell_pre_train{pre_pcell, post_pcell}, ...
		      pcell_post_train{pre_pcell, post_pcell}, ...
		      pcell_xcorr_struct{pre_pcell, post_pcell}, ...
		      pcell_pre_ndx{pre_pcell, post_pcell}, ...
		      pcell_size_pre{pre_pcell, post_pcell}, ...

		      pcell_post_ndx{pre_pcell, post_pcell}, ...
		      pcell_size_post{pre_pcell, post_pcell}, ...
		      pcell_is_auto{pre_pcell, post_pcell}, ...
		      pcell_xcorr_flag{pre_pcell, post_pcell});
	  endfor
	endfor
      else
	[pcell_mass_xcorr, ...
	 pcell_mass_autocorr, ...
	 pcell_mass_xcorr_mean, ...
	 pcell_mass_xcorr_std] = ...
	    parcellfun(NUM_PROCS, ...
		       @pvp_xcorr2, ...
		       pcell_pre_train, ...
		       pcell_post_train, ...
		       pcell_xcorr_struct, ...
		       pcell_pre_ndx, ...
		       pcell_size_pre, ...
		       pcell_post_ndx, ...
		       pcell_size_post, ...
		       pcell_is_auto, ...
		       pcell_xcorr_flag, ...
		       "UniformOutput", false);
      endif
      %% ,"VerboseLevel", 2);
      for pre_pcell = 1 : NUM_PROCS
	for post_pcell = 1 : NUM_PROCS
	  mass_target_xcorr{i_target, layer} = ...
	      mass_target_xcorr{i_target, layer} + ...
              pcell_mass_xcorr{pre_pcell, post_pcell};
	  mass_target_autocorr{i_target, layer} = ...
	      mass_target_autocorr{i_target, layer} + ...
              pcell_mass_autocorr{pre_pcell, post_pcell};
	endfor
      endfor
      mass_target_xcorr{i_target, layer} = ...
	  mass_target_xcorr{i_target, layer} / (NUM_PROCS*NUM_PROCS);
      mass_target_autocorr{i_target, layer} = ...
	  mass_target_autocorr{i_target, layer} / (NUM_PROCS*NUM_PROCS);

    endfor %%  i_target
    

    %% clutter xcorr
    i_target = 1;
    disp([layer_struct.layerID{layer}, ...
          ' ', 'mass_clutter_xcorr', ...
          '(', ...
            num2str(layer), ',', num2str(i_epoch), ')']);
    is_auto = 1;
    clutter_ndx_tmp = ...
	target_struct.clutter_ndx_max{layer, i_target};
    num_clutter_neurons_tmp = ...
	target_struct.num_clutter_neurons_max(layer, i_target);
    num_per_proc = num_clutter_neurons_tmp / NUM_PROCS;
    pcell_ndx = cell(NUM_PROCS, 1);
    pcell_first = 1;
    pcell_last = round(num_per_proc);
    for i_pcell = 1 : NUM_PROCS
      pcell_first = 1 + round( num_per_proc * ( i_pcell - 1 ) );
      pcell_first = pcell_first + (pcell_first == pcell_last);
      pcell_last = round( num_per_proc * i_pcell );
      pcell_ndx{i_pcell, 1} = ...
	  clutter_ndx_tmp(pcell_first:pcell_last);
    endfor
    xcorr_struct_tmp = xcorr_struct;
    xcorr_struct = struct;
    xcorr_struct.max_lag = xcorr_struct_tmp.max_lag;
    xcorr_struct.min_freq_ndx = xcorr_struct_tmp.min_freq_ndx;
    xcorr_struct.max_freq_ndx = xcorr_struct_tmp.max_freq_ndx;

    pcell_pre_train = cell(NUM_PROCS);
    pcell_post_train = cell(NUM_PROCS);
    pcell_xcorr_struct = cell(NUM_PROCS);
    pcell_pre_ndx = cell(NUM_PROCS);
    pcell_size_pre = cell(NUM_PROCS);
    pcell_post_ndx = cell(NUM_PROCS);
    pcell_size_post = cell(NUM_PROCS);
    pcell_is_auto = cell(NUM_PROCS);
    pcell_xcorr_flag = cell(NUM_PROCS);      
    for pre_pcell = 1 : NUM_PROCS
      for post_pcell = 1 : NUM_PROCS
	pcell_pre_train{pre_pcell, post_pcell} = ...
	    spike_array(stim_steps, ...
			pcell_ndx{pre_pcell, 1});
	pcell_post_train{pre_pcell, post_pcell} = ...
	    spike_array(stim_steps, ...
			pcell_ndx{post_pcell, 1});
	pcell_xcorr_struct{pre_pcell, post_pcell} = ...
	    xcorr_struct;
	pcell_pre_ndx{pre_pcell, post_pcell} = ...
	    pcell_ndx{pre_pcell, 1};
	pcell_size_pre{pre_pcell, post_pcell} = ...
	    layer_struct.size_layer{layer};
	pcell_post_ndx{pre_pcell, post_pcell} = ...
	    pcell_ndx{post_pcell, 1};
	pcell_size_post{pre_pcell, post_pcell} = ...
	    layer_struct.size_layer{layer};
	pcell_is_auto{pre_pcell, post_pcell} = ...
	    is_auto && (pre_pcell == post_pcell);
	pcell_xcorr_flag{pre_pcell, post_pcell} = ...
	    xcorr_flag;
      endfor
    endfor
    xcorr_struct = xcorr_struct_tmp;
    
    %% execute pvp_xcorr2 in parallel using parcellfun
    [pcell_mass_xcorr, ...
     pcell_mass_autocorr, ...
     pcell_mass_xcorr_mean, ...
     pcell_mass_xcorr_std] = ...
	parcellfun(NUM_PROCS, ...
		   @pvp_xcorr2, ...
		   pcell_pre_train, ...
		   pcell_post_train, ...
		   pcell_xcorr_struct, ...
		   pcell_pre_ndx, ...
		   pcell_size_pre, ...
		   pcell_post_ndx, ...
		   pcell_size_post, ...
		   pcell_is_auto, ...
		   pcell_xcorr_flag, ...
		   "UniformOutput", 0);
    for pre_pcell = 1 : NUM_PROCS
      for post_pcell = 1 : NUM_PROCS
	mass_clutter_xcorr{i_target, layer} = ...
	    mass_clutter_xcorr{i_target, layer} + ...
            pcell_mass_xcorr{pre_pcell, post_pcell};
	mass_clutter_autocorr{i_target, layer} = ...
	    mass_clutter_autocorr{i_target, layer} + ...
            pcell_mass_autocorr{pre_pcell, post_pcell};
      endfor
    endfor
    mass_clutter_xcorr{i_target, layer} = ...
	mass_clutter_xcorr{i_target, layer} / (NUM_PROCS*NUM_PROCS);
    mass_clutter_autocorr{i_target, layer} = ...
	mass_clutter_autocorr{i_target, layer} / (NUM_PROCS*NUM_PROCS);
    

    %% target2clutter xcorr
    disp([layer_struct.layerID{layer}, ...
          ' ', 'mass_target2clutter_xcorr', ...
          '(', ...
            num2str(layer), ',', num2str(i_epoch), ')']);
    is_auto = 0;
    for i_target = 1 : target_struct.num_targets

      %% set up cell arrays for parcellfun
      target_ndx_tmp = ...
	  target_struct.target_ndx_max{layer, i_target};
      num_target_neurons_tmp = ...
	  target_struct.num_target_neurons_max(layer, i_target);
      target_per_proc = num_target_neurons_tmp / NUM_PROCS;
      pcell_target_ndx = cell(NUM_PROCS, 1);
      pcell_target_first = 1;
      pcell_target_last = round(target_per_proc);
      for i_pcell = 1 : NUM_PROCS
	pcell_target_first = 1 + round( target_per_proc * ( i_pcell - 1 ) );
	pcell_target_first = ...
	    pcell_target_first + (pcell_target_first == pcell_target_last);
	pcell_target_last = round( target_per_proc * i_pcell );
	pcell_target_ndx{i_pcell, 1} = ...
	    target_ndx_tmp(pcell_target_first:pcell_target_last);
      endfor
      clutter_ndx_tmp = ...
	  target_struct.clutter_ndx_max{layer, i_target};
      num_clutter_neurons_tmp = ...
	  target_struct.num_clutter_neurons_max(layer, i_target);
      clutter_per_proc = num_clutter_neurons_tmp / NUM_PROCS;
      pcell_clutter_ndx = cell(NUM_PROCS, 1);
      pcell_clutter_first = 1;
      pcell_clutter_last = round(clutter_per_proc);
      for i_pcell = 1 : NUM_PROCS
	pcell_clutter_first = 1 + round( clutter_per_proc * ( i_pcell - 1 ) );
	pcell_clutter_first = ...
	    pcell_clutter_first + (pcell_clutter_first == pcell_clutter_last);
	pcell_clutter_last = round( clutter_per_proc * i_pcell );
	pcell_clutter_ndx{i_pcell, 1} = ...
	    clutter_ndx_tmp(pcell_clutter_first:pcell_clutter_last);
      endfor
      xcorr_struct_tmp = xcorr_struct;
      xcorr_struct = struct;
      xcorr_struct.max_lag = xcorr_struct_tmp.max_lag;
      xcorr_struct.min_freq_ndx = xcorr_struct_tmp.min_freq_ndx;
      xcorr_struct.max_freq_ndx = xcorr_struct_tmp.max_freq_ndx;
      
      pcell_pre_train = cell(NUM_PROCS);
      pcell_post_train = cell(NUM_PROCS);
      pcell_xcorr_struct = cell(NUM_PROCS);
      pcell_pre_ndx = cell(NUM_PROCS);
      pcell_size_pre = cell(NUM_PROCS);
      pcell_post_ndx = cell(NUM_PROCS);
      pcell_size_post = cell(NUM_PROCS);
      pcell_is_auto = cell(NUM_PROCS);
      pcell_xcorr_flag = cell(NUM_PROCS);      
      for pre_pcell = 1 : NUM_PROCS
	for post_pcell = 1 : NUM_PROCS
	  pcell_pre_train{pre_pcell, post_pcell} = ...
	      spike_array(stim_steps, ...
			  pcell_target_ndx{pre_pcell, 1});
	  pcell_post_train{pre_pcell, post_pcell} = ...
	      spike_array(stim_steps, ...
			  pcell_clutter_ndx{post_pcell, 1});
	  pcell_xcorr_struct{pre_pcell, post_pcell} = ...
	      xcorr_struct;
	  pcell_pre_ndx{pre_pcell, post_pcell} = ...
	      pcell_target_ndx{pre_pcell, 1};
	  pcell_size_pre{pre_pcell, post_pcell} = ...
	      layer_struct.size_layer{layer};
	  pcell_post_ndx{pre_pcell, post_pcell} = ...
	      pcell_clutter_ndx{post_pcell, 1};
	  pcell_size_post{pre_pcell, post_pcell} = ...
	      layer_struct.size_layer{layer};
	  pcell_is_auto{pre_pcell, post_pcell} = ...
	      is_auto && (pre_pcell == post_pcell);
	  pcell_xcorr_flag{pre_pcell, post_pcell} = ...
	      xcorr_flag;
	endfor
      endfor
      xcorr_struct = xcorr_struct_tmp;
      
      %% execute pvp_xcorr2 in parallel using parcellfun
      [pcell_mass_xcorr, ...
       pcell_mass_autocorr, ...
       pcell_mass_xcorr_mean, ...
       pcell_mass_xcorr_std] = ...
	  parcellfun(NUM_PROCS, ...
		     @pvp_xcorr2, ...
		     pcell_pre_train, ...
		     pcell_post_train, ...
		     pcell_xcorr_struct, ...
		     pcell_pre_ndx, ...
		     pcell_size_pre, ...
		     pcell_post_ndx, ...
		     pcell_size_post, ...
		     pcell_is_auto, ...
		     pcell_xcorr_flag, ...
		     "UniformOutput", 0);
      for pre_pcell = 1 : NUM_PROCS
	for post_pcell = 1 : NUM_PROCS
	  mass_target2clutter_xcorr{i_target, layer} = ...
	      mass_target2clutter_xcorr{i_target, layer} + ...
              pcell_mass_xcorr{pre_pcell, post_pcell};
	  mass_target2clutter_autocorr{i_target, layer} = ...
	      mass_target2clutter_autocorr{i_target, layer} + ...
              pcell_mass_autocorr{pre_pcell, post_pcell};
	endfor
      endfor
      mass_target2clutter_xcorr{i_target, layer} = ...
	  mass_target2clutter_xcorr{i_target, layer} / (NUM_PROCS*NUM_PROCS);
      mass_target2clutter_autocorr{i_target, layer} = ...
	  mass_target2clutter_autocorr{i_target, layer} / (NUM_PROCS*NUM_PROCS);

    endfor %% % i_target
    
  endfor %% i_epoch
  