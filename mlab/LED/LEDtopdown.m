function [dLED_state_dt] = LEDtopdown( ...
    LED_time, ...
    LED_state, ...
    image_pattern, ...
    mask_pattern, ...
    target_pattern, ...
    distractor_pattern, ...
    time_SoA, ...
    tau_segment, ...
    tau_detector, ...
    kappa_struct, ...
    semantic_flag )

  global num_LED_segs
  global LED_segment_threshold_exc LED_segment_threshold_inh
  global LED_segment_exp_exc LED_segment_exp_inh

				% global LED_segment_prior
				% global LED_detector_prior


if isempty(num_LED_segs)
    num_LED_segs = ( size(LED_state, 1) / 2 ) - 2;
end

% if isempty(LED_segment_prior)
%     LED_segment_prior = 0.5;
% end

% if isempty(LED_detector_prior)
%     LED_detector_prior = 0.5;
% end

% we typically have ( 7 + 3 ) dynamical variables, 7 LED segments and 3 detectors (mask, target, distractor)
LED_segment = LED_state(1:num_LED_segs, 1);
LED_target  = LED_state(1*num_LED_segs + 1, 1);
LED_mask = LED_state(1*num_LED_segs + 2, 1);
LED_distractor = LED_state(1*num_LED_segs + 3, 1);

% fix LED patterns
LED_image_pattern(1:num_LED_segs,1)  =  image_pattern(1,1:num_LED_segs);
LED_target_pattern(1:num_LED_segs,1) = target_pattern(1,1:num_LED_segs);
LED_mask_pattern(1:num_LED_segs,1)  = mask_pattern(1,1:num_LED_segs);
LED_distractor_pattern(1:num_LED_segs,1) = distractor_pattern(1,1:num_LED_segs);

% image segment equation:
d_segment_dt = ...
    - (1/tau_segment) * ...
    ( LED_segment - ...
    ( time_SoA >= LED_time ) * LED_image_pattern - ...
    ( time_SoA < LED_time ) * LED_mask_pattern - ...
    ( ( LED_segment > 1.0 ) .* ( 1.0 - exp( ( LED_segment - 1.0 ) / kappa_struct.gain ) ) ) - ...
    ( ( LED_segment < 0.0 ) .* ( exp( ( -LED_segment ) / kappa_struct.gain )  - 1.0 ) ) - ...
    ( kappa_struct.feedback_present * LED_target_pattern * min(LED_target, 1.0) * (LED_target>0) ) - ...
    ( kappa_struct.feedback_absent * ( 1 - LED_target_pattern ) * min(LED_target, 1.0) * (LED_target>0) )  - ...
    ( kappa_struct.feedback_present * LED_mask_pattern * min(LED_mask, 1.0) * (LED_mask>0) ) - ...
    ( kappa_struct.feedback_absent * ( 1 - LED_mask_pattern ) * min(LED_mask, 1.0) * (LED_mask>0) ) - ...
    ( kappa_struct.feedback_present * LED_distractor_pattern * min(LED_distractor, 1.0) * (LED_distractor>0) ) - ...
    ( kappa_struct.feedback_absent * ( 1 - LED_distractor_pattern ) * min(LED_distractor, 1.0) * (LED_distractor>0) ) );

% target detector equation
d_target_dt = ...
    - (1/tau_detector) * ...
    ( LED_target - ...
    ( ( LED_target > 1.0 ) .* ( 1.0 - exp( ( LED_target - 1.0 ) * kappa_struct.gain ) ) ) - ...
    ( ( LED_target < 0.0 ) .* ( exp( ( -LED_target ) * kappa_struct.gain ) - 1.0) ) - ...
    kappa_struct.feedforward_present * ( sum( LED_target_pattern .* ( LED_segment ) .* (LED_segment>LED_segment_threshold_exc) )  / ...
    ( sum( LED_target_pattern ) + (sum( LED_target_pattern ) == 0 ) ) ) .^ LED_segment_exp_exc - ...
    kappa_struct.OFF_OFF_symmetry * kappa_struct.feedforward_present * ( sum( ( 1 - LED_target_pattern ) .* min((1.0 - LED_segment ), 1.0) .* (LED_segment<1) ) / ...
    ( sum( 1 - LED_target_pattern ) + (sum( 1 - LED_target_pattern ) == 0 ) ) ) .^ LED_segment_exp_exc - ...
    kappa_struct.feedforward_absent * ( sum( ( 1 - LED_target_pattern ) .* ( LED_segment ) .* (LED_segment>LED_segment_threshold_inh) ) / ...
    ( sum( 1 - LED_target_pattern ) + (sum( 1 - LED_target_pattern ) == 0 ) ) ) .^ LED_segment_exp_inh - ...
    kappa_struct.ON_OFF_symmetry * kappa_struct.feedforward_absent * ( sum( LED_target_pattern .* min((1.0 - LED_segment ), 1.0) .* (LED_segment<1) ) / ...
    ( sum( LED_target_pattern ) + (sum( LED_target_pattern ) == 0 ) ) ) .^ LED_segment_exp_inh - ...
    kappa_struct.winner_take_all_inhib * LED_mask * (LED_mask > 0) - ...
    kappa_struct.winner_take_all_inhib * LED_distractor * (LED_distractor > 0) );

% mask equations:
d_mask_dt = ...
    - (1/tau_detector) * ...
    ( LED_mask - ...
    ( ( LED_mask > 1.0 ) .* ( 1.0 - exp( ( LED_mask - 1.0 ) * kappa_struct.gain ) ) ) - ...
    ( ( LED_mask < 0.0 ) .* ( exp( ( -LED_mask ) * kappa_struct.gain ) - 1.0) ) - ...
    kappa_struct.feedforward_present * ( sum( LED_mask_pattern .* ( LED_segment ) .* (LED_segment>LED_segment_threshold_exc) ) / ...
    ( sum( LED_mask_pattern ) + (sum( LED_mask_pattern ) == 0 ) ) ) .^ LED_segment_exp_exc - ...
    kappa_struct.OFF_OFF_symmetry * kappa_struct.feedforward_present * ( sum( ( 1 - LED_mask_pattern ) .* min((1.0 - LED_segment ), 1.0) .* (LED_segment<1) ) / ...
    ( sum( 1 - LED_mask_pattern ) + (sum( 1 - LED_mask_pattern ) == 0 ) ) ) .^ LED_segment_exp_exc - ...
    kappa_struct.feedforward_absent * ( sum( ( 1 - LED_mask_pattern ) .* ( LED_segment ) .* (LED_segment>LED_segment_threshold_inh) ) / ...
    ( sum( 1 - LED_mask_pattern ) + (sum( 1 - LED_mask_pattern ) == 0 ) ) ) .^ LED_segment_exp_inh - ...
    kappa_struct.ON_OFF_symmetry * kappa_struct.feedforward_absent * ( sum( LED_mask_pattern .* min((1.0 - LED_segment ), 1.0) .* (LED_segment<1) ) / ...
    ( sum( LED_mask_pattern ) + (sum( LED_mask_pattern ) == 0 ) ) ) .^ LED_segment_exp_inh  - ...
    kappa_struct.winner_take_all_inhib * LED_target * (LED_target > 0)  - ...
    kappa_struct.winner_take_all_inhib * LED_distractor * (LED_distractor > 0) );

% distractor detector equation
d_distractor_dt = ...
    - (1/tau_detector) * ...
    ( LED_distractor - ...
    ( ( LED_distractor > 1.0 ) .* ( 1.0 - exp( ( LED_distractor - 1.0 ) * kappa_struct.gain ) ) ) - ...
    ( ( LED_distractor < 0.0 ) .* ( exp( ( -LED_distractor ) * kappa_struct.gain ) - 1.0) ) - ...
    kappa_struct.feedforward_present * ( sum( LED_distractor_pattern .* ( LED_segment ) .* (LED_segment>LED_segment_threshold_exc) ) / ...
    ( sum( LED_distractor_pattern ) + (sum( LED_distractor_pattern ) == 0 ) ) ) .^ LED_segment_exp_exc - ...
    kappa_struct.OFF_OFF_symmetry * kappa_struct.feedforward_present * ( sum( ( 1 - LED_distractor_pattern ) .* min((1.0 - LED_segment ), 1.0) .* (LED_segment<1) ) / ...
    ( sum( 1 - LED_distractor_pattern ) + (sum( 1 - LED_distractor_pattern ) == 0 ) ) ) .^ LED_segment_exp_exc - ...
    kappa_struct.feedforward_absent * ( sum( ( 1 - LED_distractor_pattern ) .* ( LED_segment )  .* (LED_segment>LED_segment_threshold_inh) ) / ...
    ( sum( 1 - LED_distractor_pattern ) + (sum( 1 - LED_distractor_pattern ) == 0 ) ) ) .^ LED_segment_exp_inh - ...
    kappa_struct.ON_OFF_symmetry * kappa_struct.feedforward_absent * ( sum( LED_distractor_pattern .* min((1.0 - LED_segment ), 1.0) .* (LED_segment<1) ) / ...
    ( sum( LED_distractor_pattern ) + (sum( LED_distractor_pattern ) == 0 ) ) ) .^ LED_segment_exp_inh  - ...
    kappa_struct.winner_take_all_inhib * LED_mask * (LED_mask > 0) - ...
    kappa_struct.winner_take_all_inhib * LED_target * (LED_target > 0) );

dLED_state_dt = [d_segment_dt; d_target_dt; d_mask_dt; d_distractor_dt];

