/*
 * OccludingGSynAccumulator.kpp
 *
 *  Created on: Jul 18, 2019
 *      Author: Jacob Springer
 */

// Creates functions updateOccludingGSynAccumulatorOnGPU and updateOccludingGSynAccumulatorOnCPU,
// that take the same argument list and use the same core code, except that
// one is run from the .cu file and the other is run from the .cpp file.
// The .cu file defines the preprocessor directive PV_RUN_ON_GPU before
// including this file; the and the .cpp file undefines it.

#ifdef PV_RUN_ON_GPU
namespace PVCuda {
__global__ void updateOccludingGSynAccumulatorOnGPU
#else
namespace PV {
inline void updateOccludingGSynAccumulatorOnCPU
#endif // PV_RUN_ON_GPU
      (int const nbatch,
       int const nx,
       int const ny,
       int const nf,
       int const numChannel,
       float const *layerInput,
       float *bufferData,
       float *contribData) {

   int const numNeuronsAcrossBatch = nx * ny * nf * nbatch;
   int const numPixelsAcrossBatch = nx * ny * nbatch;

#ifdef PV_RUN_ON_GPU
   int index = (blockIdx.x * blockDim.x) + threadIdx.x;
   if (index < numPixelsAcrossBatch)
#else
#ifdef PV_USE_OPENMP_THREADS
#pragma omp parallel for schedule(static)
#endif
   for (int index = 0; index < numPixelsAcrossBatch; index++)
#endif // PV_RUN_ON_GPU
   {
      float const *layerInputXYCh = &(layerInput[ch * numNeuronsAcrossBatch + index * nf]); 

      if (numChannels > 0) {
         // Unroll first iteration for base case
         float magnitude = 0.0f;
         for (int i = 0; i < nf; i++) {
            magnitude += layerInputXYCh[i] * layerInputXYCh[i];
         }
         contribData[index] = sqrtf(magnitude);
      
         // Inductively compute contribution
         for (int ch = 1; ch < numChannels; ch++) {
            float magnitude = 0.0f;
            for (int i = 0; i < nf; i++) {
               magnitude += layerInputXYCh[i] * layerInputXYCh[i];
            }
            float prevContrib = contribData[(ch - 1) * numPixelsAcrossBatch + index];
            contribData[ch * numPixelsAcrossBatch + index] = (1 - prevContrib) * sqrtf(magnitude);
         }
      }
      
      // Sum each layer weighted by contribution
      for (int i = 0; i < nf; i++) {
         float value = 0.0f;
         for (int ch = 0; ch < numChannels; ch++) {
            float a = contribData[ch * numPixelsAcrossBatch + index];
            value += a * layerInputXYCh[i];
         }
         bufferData[index * nf + i] = value;
      }
   }
}

} // namespace (PV or PVCuda)
