/*
 * OccludingGSynAccumulator.kpp
 *
 *  Created on: Jul 18, 2019
 *      Author: Jacob Springer
 */

// Creates functions updateOccludingGSynAccumulatorOnGPU and updateOccludingGSynAccumulatorOnCPU,
// that take the same argument list and use the same core code, except that
// one is run from the .cu file and the other is run from the .cpp file.
// The .cu file defines the preprocessor directive PV_RUN_ON_GPU before
// including this file; the and the .cpp file undefines it.
#ifdef PV_RUN_ON_GPU
namespace PVCuda {
__global__ void updateOccludingGSynAccumulatorOnGPU
#else
namespace PV {
inline void updateOccludingGSynAccumulatorOnCPU
#endif // PV_RUN_ON_GPU
      (int const nbatch,
       int const nx,
       int const ny,
       int const nf,
       int const numChannels,
       float const opaqueMagnitude,
       float const *layerInput,
       float *bufferData,
       float *contribData) {

   int const numNeuronsAcrossBatch = nx * ny * nf * nbatch;
   int const numPixelsAcrossBatch = nx * ny * nbatch;

#ifdef PV_RUN_ON_GPU
   int index = (blockIdx.x * blockDim.x) + threadIdx.x;
   if (index < numPixelsAcrossBatch)
#else
#ifdef PV_USE_OPENMP_THREADS
#pragma omp parallel for schedule(static)
#endif
   for (int index = 0; index < numPixelsAcrossBatch; index++)
#endif // PV_RUN_ON_GPU
   {
      float filter = 1.0;
      for (int ch = 0; ch < numChannels; ch++) {
         float const *layerInputXYCh = &(layerInput[ch * numNeuronsAcrossBatch + index * nf]); 
         float magnitude = 0.0f;

         for (int i = 0; i < nf; i++) {
            magnitude += layerInputXYCh[i] * layerInputXYCh[i];
         }

         contribData[ch * numPixelsAcrossBatch + index] = filter; 
         filter *= fmaxf(0.0, opaqueMagnitude - sqrtf(magnitude)) / opaqueMagnitude;
      }
      
      // Sum each layer weighted by contribution
      for (int i = 0; i < nf; i++) {
         float value = 0.0f;
         for (int ch = 0; ch < numChannels; ch++) {
            float const *layerInputXYCh = &(layerInput[ch * numNeuronsAcrossBatch + index * nf]); 
            float a = contribData[ch * numPixelsAcrossBatch + index];
            value += a * layerInputXYCh[i];
         }
         bufferData[index * nf + i] = value;
      }
   }
}

} // namespace (PV or PVCuda)
