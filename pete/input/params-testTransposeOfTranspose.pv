// params-testTransposeOfTranspose.pv
//     input parameters file for testing whether the transpose of the
//     transpose is the original map. 

FileDefinition "ImageFileList" =  "./input/mnist/filenames.txt";
FileDefinition "OutputDir" =      "./output/generativelateral/mnist"; // not used yet

HyPerCol "column" = {
    nx = 32;            // number of horizontal pixels in the column
    ny = 32;            // number of vertical pixels in the column
    dt = 1;             // time increment per timestep
    randomSeed = 118;   // seed the column's random number generator.
};

// 6 layers:  Slideshow,
//            Retina,
//            Layer A,
//            Layer B One to one
//            Layer B Many to one
//            Layer B One to many

HyPerLayer "Slideshow" = {
    restart = 0;        // whether to load *_last.pvp files at initialization
    nxScale = 1;        // scale factor between layer size and column size
    nyScale = 1;        // layer size = n{x,y}Scale * (column size)
    nf = 1;             // Number of features.  For images, use nf=3 for RGB
    marginWidth = 0;    // Width of margin padding in pixels
    // writeStep        // How often to write updates; not used yet
    mirrorBCflag = 0;   // Whether to use mirror boundary conditions at edges
    spikingFlag = 0;    // Whether there is spiking
    writeNonspikingActivity = 0;
        // Whether to write activity at each step in the nonspiking case 
    
    writeImages = 0;    // Whether to write image during outputState

    displayPeriod = 50; // Length of time each image in the movie is presented
    persistenceProb = 1;// Probability of no jitter when updateImage is called
    // recurrenceProb   // Probability that offset returns to bias position
    stepSize = 0;       // Amount of jitter each direction when jitter occurs
    biasChangeTime = 10000; // How often to update bias position
    writePosition = 0;  // Whether to write bias and offset to image-pos.txt
    randomMovie = 0;    // Whether to call randomFrame()
    // randomMovieProb  // If randomMovie != 0, prob that a given pixel is 1.
    offsetX = 0;        // Initial horizontal offset into image
    offsetY = 0;        // Initial vertical offset into image
};

HyPerLayer "Retina" = {
    restart = 0;        // whether to load *_last.pvp files at initialization
    nxScale = 1;        // scale factor between layer size and column size
    nyScale = 1;        // layer size = n{x,y}Scale * (column size)
    nf = 1;             // Number of features.  For images, use nf=3 for RGB
    marginWidth = 3;    // Width of margin padding in pixels
    writeStep = 1.0;    // How often to write updates; not used yet
    mirrorBCflag = 1;   // Whether to use mirror boundary conditions at edges
    spikingFlag = 0;    // Whether there is spiking
    writeNonspikingActivity = 0;
        // Whether to write activity at each step in the nonspiking case 
    
    // fireOffPixels    // Currently commented out
    // invert           // In deprecated or obsolete sections
    // uncolor          // In deprecated or obsolete sections
    poissonEdgeProb = 1; 
    poissonBlankProb = 0;
    burstFreq = 1;
    burstDuration = 40000;
    // noiseOnFreq      // If present, poissonEdgeProb set to
                        // min(1, noiseOnFreq * parent column's dt);
                        // overrides setting poissonEdgeProb in this file
    // noiseOffFreq     // If present, poissonBlankProb set to
                        // min(1, noiseOffFreq * parent column's dt);
                        // overrides setting poissonBlankProb in this file
    beginStim = 1;
    endStim = 40000;
};

HyPerLayer "Layer A" = {
    restart = 0;        // whether to load *_last.pvp files at initialization
    nxScale = 1;        // scale factor between layer size and column size
    nyScale = 1;        // layer size = n{x,y}Scale * (column size)
    nf = 8;             // Number of features.  For images, use nf=3 for RGB
    marginWidth = 14;    // Width of margin padding in pixels
    writeStep = 1.0;    // How often to write updates; not used yet
    mirrorBCflag = 1;   // Whether to use mirror boundary conditions at edges
    spikingFlag = 0;    // Whether there is spiking
    writeNonspikingActivity = 0;
        // Whether to write activity at each step in the nonspiking case

    Vrest = 0.0;        // Sets initial value of clayer->V
    // Vexc             // Only used by updateFunc, which doesn't get called
    // Vinh             // Only used by updateFunc, which doesn't get called
    // VinhB            // Only used by updateFunc, which doesn't get called
    // tau              // Only used by updateFunc, which doesn't get called
    // tauE             // Only used by updateFunc, which doesn't get called
    // tauI             // Only used by updateFunc, which doesn't get called
    // tauIB            // Only used by updateFunc, which doesn't get called
    // VthRest          // Sets initial value of clayer->Vth
    // tauVth           // Only used by updateFunc, which doesn't get called
    // deltaVth         //
    noiseAmpE = 0.0;    // If positive, adds random noise to V,Vth,G[k];
                        // also initial value of clayer->G_E
    noiseAmpI = 0.0;    // If positive, adds random noise to V,Vth,G[k];
                        // also initial value of clayer->G_E
    // noiseAmpIB       // Sets initial value of clayer->G_IB
                        // if either noiseAmpE or noiseAmpI is positive
    // noiseFreqE       // Only used by updateFunc, which doesn't get called
    // noiseFreqI       // Only used by updateFunc, which doesn't get called
    // noiseFreqIB      // Only used by updateFunc, which doesn't get called
    
    relaxation = 5E-3;  // GenerativeLayer rule: V(new) = V(old) + relaxation*dV/dt
};

HyPerLayer "Layer B One to one" = {
    restart = 0;        // whether to load *_last.pvp files at initialization
    nxScale = 1.0;        // scale factor between layer size and column size
    nyScale = 1.0;        // layer size = n{x,y}Scale * (column size)
    nf = 8;            // Number of features.  For images, use nf=3 for RGB
    marginWidth = 8;   // Width of margin padding in pixels
    writeStep = 1.0;    // How often to write updates; not used yet
    mirrorBCflag = 1;   // Whether to use mirror boundary conditions at edges
    spikingFlag = 0;    // Whether there is spiking
    writeNonspikingActivity = 0;
        // Whether to write activity at each step in the nonspiking case

    Vrest = 0.0;        // Sets initial value of clayer->V
    // Vexc             // Only used by updateFunc, which doesn't get called
    // Vinh             // Only used by updateFunc, which doesn't get called
    // VinhB            // Only used by updateFunc, which doesn't get called
    // tau              // Only used by updateFunc, which doesn't get called
    // tauE             // Only used by updateFunc, which doesn't get called
    // tauI             // Only used by updateFunc, which doesn't get called
    // tauIB            // Only used by updateFunc, which doesn't get called
    // VthRest          // Sets initial value of clayer->Vth
    // tauVth           // Only used by updateFunc, which doesn't get called
    // deltaVth         //
    noiseAmpE = 0.0;    // If positive, adds random noise to V,Vth,G[k];
                        // also initial value of clayer->G_E
    noiseAmpI = 0.0;    // If positive, adds random noise to V,Vth,G[k];
                        // also initial value of clayer->G_E
    // noiseAmpIB       // Sets initial value of clayer->G_IB
                        // if either noiseAmpE or noiseAmpI is positive
    // noiseFreqE       // Only used by updateFunc, which doesn't get called
    // noiseFreqI       // Only used by updateFunc, which doesn't get called
    // noiseFreqIB      // Only used by updateFunc, which doesn't get called
    
    relaxation = 5E-3;  // GenerativeLayer rule: V(new) = V(old) + relaxation*dV/dt
};

HyPerLayer "Layer B Many to one" = {
    restart = 0;        // whether to load *_last.pvp files at initialization
    nxScale = 0.5;      // scale factor between layer size and column size
    nyScale = 0.5;      // layer size = n{x,y}Scale * (column size)
    nf = 32;            // Number of features.  For images, use nf=3 for RGB
    marginWidth = 8;    // Width of margin padding in pixels
    writeStep = 1.0;    // How often to write updates; not used yet
    mirrorBCflag = 1;   // Whether to use mirror boundary conditions at edges
    spikingFlag = 0;    // Whether there is spiking
    writeNonspikingActivity = 0;
        // Whether to write activity at each step in the nonspiking case

    Vrest = 0.0;        // Sets initial value of clayer->V
    // Vexc             // Only used by updateFunc, which doesn't get called
    // Vinh             // Only used by updateFunc, which doesn't get called
    // VinhB            // Only used by updateFunc, which doesn't get called
    // tau              // Only used by updateFunc, which doesn't get called
    // tauE             // Only used by updateFunc, which doesn't get called
    // tauI             // Only used by updateFunc, which doesn't get called
    // tauIB            // Only used by updateFunc, which doesn't get called
    // VthRest          // Sets initial value of clayer->Vth
    // tauVth           // Only used by updateFunc, which doesn't get called
    // deltaVth         //
    noiseAmpE = 0.0;    // If positive, adds random noise to V,Vth,G[k];
                        // also initial value of clayer->G_E
    noiseAmpI = 0.0;    // If positive, adds random noise to V,Vth,G[k];
                        // also initial value of clayer->G_E
    // noiseAmpIB       // Sets initial value of clayer->G_IB
                        // if either noiseAmpE or noiseAmpI is positive
    // noiseFreqE       // Only used by updateFunc, which doesn't get called
    // noiseFreqI       // Only used by updateFunc, which doesn't get called
    // noiseFreqIB      // Only used by updateFunc, which doesn't get called
    
    relaxation = 5E-3;  // GenerativeLayer rule: V(new) = V(old) + relaxation*dV/dt
};

HyPerLayer "Layer B One to many" = {
    restart = 0;        // whether to load *_last.pvp files at initialization
    nxScale = 2.0;      // scale factor between layer size and column size
    nyScale = 2.0;      // layer size = n{x,y}Scale * (column size)
    nf = 2;             // Number of features.  For images, use nf=3 for RGB
    marginWidth = 14;    // Width of margin padding in pixels
    writeStep = 1.0;    // How often to write updates; not used yet
    mirrorBCflag = 1;   // Whether to use mirror boundary conditions at edges
    spikingFlag = 0;    // Whether there is spiking
    writeNonspikingActivity = 0;
        // Whether to write activity at each step in the nonspiking case

    Vrest = 0.0;        // Sets initial value of clayer->V
    // Vexc             // Only used by updateFunc, which doesn't get called
    // Vinh             // Only used by updateFunc, which doesn't get called
    // VinhB            // Only used by updateFunc, which doesn't get called
    // tau              // Only used by updateFunc, which doesn't get called
    // tauE             // Only used by updateFunc, which doesn't get called
    // tauI             // Only used by updateFunc, which doesn't get called
    // tauIB            // Only used by updateFunc, which doesn't get called
    // VthRest          // Sets initial value of clayer->Vth
    // tauVth           // Only used by updateFunc, which doesn't get called
    // deltaVth         //
    noiseAmpE = 0.0;    // If positive, adds random noise to V,Vth,G[k];
                        // also initial value of clayer->G_E
    noiseAmpI = 0.0;    // If positive, adds random noise to V,Vth,G[k];
                        // also initial value of clayer->G_E
    // noiseAmpIB       // Sets initial value of clayer->G_IB
                        // if either noiseAmpE or noiseAmpI is positive
    // noiseFreqE       // Only used by updateFunc, which doesn't get called
    // noiseFreqI       // Only used by updateFunc, which doesn't get called
    // noiseFreqIB      // Only used by updateFunc, which doesn't get called
    
    relaxation = 5E-3;  // GenerativeLayer rule: V(new) = V(old) + relaxation*dV/dt
};



// 4 connections:   Slideshow to Retina
//                  Retina to Layer A
//                  One to one original map
//                  Many to one original map
//                  One to many original map
//                  Transpose (the same connection definition can be used for all transposes)

HyPerConn "Slideshow to Retina" = {
    nxp = 1;            // Number of horizontal pixels in each patch
    nyp = 1;            // Number of vertical pixels in each patch
    nfp = 1;            // Number of features in each patch

    stdpFlag = 0;       // Whether to use spike timing dependent plasticity
    // ampLTP           // Used to update plasticity increment pIncr
    // ampLTD           // Used to update plasticity decrement pDecr
    // tauLTP           // Used to update plasticity increment pIncr
    // tauLTD           // Used to update plasticity decrement pDecr
    
    strength = 1.0;     // Used in Gaussian weights and normalizeWeights
    aspect = 1;         // Used in Gaussian weights: aspect ratio
    sigma = 1;          // Used in Gaussian weights: standard deviation
    rMax = 1;           // Used in Gaussian weights
    numFlanks = 1;      // Used in Gaussian weights
    flankShift = 0;     // Used in Gaussian weights
    rotate = 0;         // Used in Gaussian weights
    
    // wMax             // Used in updating weight patches
                        // If wMax is not present and strength is, use strength for wMax
    // wMin             // Used in updating weight patches
    // dWMax            // Used in updating weight patches
    
    // normalize        // Whether to normalize weights during initialization
    // normalize_max    // Used to normalize if normalize flag is set
    // normalize_zero_offset  // Used to normalize if normalize flag is set
    
    initFromLastFlag = 0; // Whether to initialize wgts w/ previous run's data
    
    randomFlag = 0;     // Whether to initialize with random weights
    // uniformWeights   // If initializing w/ random weights, use uniform dist.
    // gaussianWeights  // If initializing w/ random weights, use Gaussian dist.
                        // Exactly one of uniformWeights and gaussianWeights
                        // must be set (Defaults are U=true, G=false)
    // wMinInit         // For uniform dist. random weights, the minimum value
    // wMaxInit         // For uniform dist. random weights, the maximum value
    // wGaussMean       // For Gaussian dist. random weights, the mean
    // wGaussStdev      // For Gaussian dist. random weights, the std. dev.
    
    smartWeights = 0;   // Whether to call HyPerConn::smartWeights.

    // writeStep        // How often to write updates; not used yet
    // delay            // Doesn't appear to be used
    // fixDelay         // Doesn't appear to be used
    // vel              // Doesn't appear to be used
    // rmin             // Doesn't appear to be used
    // rmax             // Doesn't appear to be used
    // varDelayMin      // Doesn't appear to be used
    // varDelayMax      // Doesn't appear to be used
    // numDelay         // Not used as params->numDelay is set to
                        // params->varDelayMax - params->varDelayMin + 1,
                        // and then params->numDelay isn't used anyway
    // isGraded         // Doesn't appear to be used
    
    // no               // Doesn't appear to be used
};

HyPerConn "Retina to Layer A" = {
    nxp = 7;            // Number of horizontal pixels in each patch
    nyp = 7;            // Number of vertical pixels in each patch
    nfp = 8;            // Number of features in each patch

    stdpFlag = 0;       // Whether to use spike timing dependent plasticity
    // ampLTP           // Used to update plasticity increment pIncr
    // ampLTD           // Used to update plasticity decrement pDecr
    // tauLTP           // Used to update plasticity increment pIncr
    // tauLTD           // Used to update plasticity decrement pDecr
    
    strength = 25.0;   // 1.0/255
                        // Used in Gaussian weights and normalizeWeights
    aspect = 7;         // Used in Gaussian weights: aspect ratio
    sigma = 7;          // Used in Gaussian weights: standard deviation
    rMax = 7;           // Used in Gaussian weights
    numFlanks = 1;      // Used in Gaussian weights
    flankShift = 0;     // Used in Gaussian weights
    rotate = 1;         // Used in Gaussian weights
    
    // wMax             // Used in updating weight patches
                        // If wMax is not present and strength is, use strength for wMax
    // wMin             // Used in updating weight patches
    // dWMax            // Used in updating weight patches
    
    // normalize        // Whether to normalize weights during initialization
    // normalize_max    // Used to normalize if normalize flag is set
    // normalize_zero_offset  // Used to normalize if normalize flag is set
    
    initFromLastFlag = 0; // Whether to initialize wgts w/ previous run's data
    
    randomFlag = 0;     // Whether to initialize with random weights
    // uniformWeights   // If initializing w/ random weights, use uniform dist.
    // gaussianWeights  // If initializing w/ random weights, use Gaussian dist.
                        // Exactly one of uniformWeights and gaussianWeights
                        // must be set (Defaults are U=true, G=false)
    // wMinInit         // For uniform dist. random weights, the minimum value
    // wMaxInit         // For uniform dist. random weights, the maximum value
    // wGaussMean       // For Gaussian dist. random weights, the mean
    // wGaussStdev      // For Gaussian dist. random weights, the std. dev.
    
    smartWeights = 0;   // Whether to call HyPerConn::smartWeights.

    // writeStep        // How often to write updates; not used yet
    // delay            // Doesn't appear to be used
    // fixDelay         // Doesn't appear to be used
    // vel              // Doesn't appear to be used
    // rmin             // Doesn't appear to be used
    // rmax             // Doesn't appear to be used
    // varDelayMin      // Doesn't appear to be used
    // varDelayMax      // Doesn't appear to be used
    // numDelay         // Not used as params->numDelay is set to
                        // params->varDelayMax - params->varDelayMin + 1,
                        // and then params->numDelay isn't used anyway
    // isGraded         // Doesn't appear to be used
    
    // no               // Doesn't appear to be used
    
    weightUpdatePeriod = 50.0; // Period between updating the weights
    relaxation = 1E-5;  // GenerativeConn rule: A(new) = A(old) + relaxation*dA/dt
};

HyPerConn "One to one original map" = {
    nxp = 15;           // Number of horizontal pixels in each patch
    nyp = 15;           // Number of vertical pixels in each patch
    nfp = 8;            // Number of features in each patch

    stdpFlag = 0;       // Whether to use spike timing dependent plasticity
    // ampLTP           // Used to update plasticity increment pIncr
    // ampLTD           // Used to update plasticity decrement pDecr
    // tauLTP           // Used to update plasticity increment pIncr
    // tauLTD           // Used to update plasticity decrement pDecr
    
    // strength = 1;       // Used in Gaussian weights and normalizeWeights
    // aspect = 3;         // Used in Gaussian weights: aspect ratio
    // sigma = 3;          // Used in Gaussian weights: standard deviation
    // rMax = 3;           // Used in Gaussian weights
    // numFlanks = 1;      // Used in Gaussian weights
    // flankShift = 0;     // Used in Gaussian weights
    // rotate = 0;         // Used in Gaussian weights
    
    // wMax             // Used in updating weight patches
                        // If wMax is not present and strength is, use strength for wMax
    // wMin             // Used in updating weight patches
    // dWMax            // Used in updating weight patches
    
    // normalize        // Whether to normalize weights during initialization
    // normalize_max    // Used to normalize if normalize flag is set
    // normalize_zero_offset  // Used to normalize if normalize flag is set
    
    initFromLastFlag = 0; // Whether to initialize wgts w/ previous run's data
    
    randomFlag = 1;     // Whether to initialize with random weights
    uniformWeights = 1; // If initializing w/ random weights, use uniform dist.
    gaussianWeights = 0; // If initializing w/ random weights, use Gaussian dist.
                        // Exactly one of uniformWeights and gaussianWeights
                        // must be set (Defaults are U=true, G=false)
    wMinInit = 0;       // For uniform dist. random weights, the minimum value
    wMaxInit = 1;       // For uniform dist. random weights, the maximum value
    // wGaussMean       // For Gaussian dist. random weights, the mean
    // wGaussStdev      // For Gaussian dist. random weights, the std. dev.
    
    smartWeights = 0;   // Whether to call HyPerConn::smartWeights.

    // writeStep        // How often to write updates; not used yet
    // delay            // Doesn't appear to be used
    // fixDelay         // Doesn't appear to be used
    // vel              // Doesn't appear to be used
    // rmin             // Doesn't appear to be used
    // rmax             // Doesn't appear to be used
    // varDelayMin      // Doesn't appear to be used
    // varDelayMax      // Doesn't appear to be used
    // numDelay         // Not used as params->numDelay is set to
                        // params->varDelayMax - params->varDelayMin + 1,
                        // and then params->numDelay isn't used anyway
    // isGraded         // Doesn't appear to be used
    
    // no               // Doesn't appear to be used

    weightUpdatePeriod = 50.0; // Period between updating the weights
    relaxation = 1E-5;  // GenerativeConn rule: A(new) = A(old) + relaxation*dA/dt
};

HyPerConn "One to one transpose" = {
    initFromLastFlag = 0; // Whether to initialize wgts w/ previous run's data
    // For feedback connections, other parameters will be inferred from the
    // associated feedforward connection 
};

HyPerConn "One to one transpose of transpose" = {
    initFromLastFlag = 0; // Whether to initialize wgts w/ previous run's data
    // For feedback connections, other parameters will be inferred from the
    // associated feedforward connection 
};

HyPerConn "Many to one original map" = {
    nxp = 15;           // Number of horizontal pixels in each patch
    nyp = 15;           // Number of vertical pixels in each patch
    nfp = 32;            // Number of features in each patch

    stdpFlag = 0;       // Whether to use spike timing dependent plasticity
    // ampLTP           // Used to update plasticity increment pIncr
    // ampLTD           // Used to update plasticity decrement pDecr
    // tauLTP           // Used to update plasticity increment pIncr
    // tauLTD           // Used to update plasticity decrement pDecr
    
    // strength = 1;       // Used in Gaussian weights and normalizeWeights
    // aspect = 3;         // Used in Gaussian weights: aspect ratio
    // sigma = 3;          // Used in Gaussian weights: standard deviation
    // rMax = 3;           // Used in Gaussian weights
    // numFlanks = 1;      // Used in Gaussian weights
    // flankShift = 0;     // Used in Gaussian weights
    // rotate = 0;         // Used in Gaussian weights
    
    // wMax             // Used in updating weight patches
                        // If wMax is not present and strength is, use strength for wMax
    // wMin             // Used in updating weight patches
    // dWMax            // Used in updating weight patches
    
    // normalize        // Whether to normalize weights during initialization
    // normalize_max    // Used to normalize if normalize flag is set
    // normalize_zero_offset  // Used to normalize if normalize flag is set
    
    initFromLastFlag = 0; // Whether to initialize wgts w/ previous run's data
    
    randomFlag = 1;     // Whether to initialize with random weights
    uniformWeights = 1; // If initializing w/ random weights, use uniform dist.
    gaussianWeights = 0; // If initializing w/ random weights, use Gaussian dist.
                        // Exactly one of uniformWeights and gaussianWeights
                        // must be set (Defaults are U=true, G=false)
    // wMinInit         // For uniform dist. random weights, the minimum value
    // wMaxInit         // For uniform dist. random weights, the maximum value
    // wGaussMean       // For Gaussian dist. random weights, the mean
    // wGaussStdev      // For Gaussian dist. random weights, the std. dev.
    
    smartWeights = 0;   // Whether to call HyPerConn::smartWeights.

    // writeStep        // How often to write updates; not used yet
    // delay            // Doesn't appear to be used
    // fixDelay         // Doesn't appear to be used
    // vel              // Doesn't appear to be used
    // rmin             // Doesn't appear to be used
    // rmax             // Doesn't appear to be used
    // varDelayMin      // Doesn't appear to be used
    // varDelayMax      // Doesn't appear to be used
    // numDelay         // Not used as params->numDelay is set to
                        // params->varDelayMax - params->varDelayMin + 1,
                        // and then params->numDelay isn't used anyway
    // isGraded         // Doesn't appear to be used
    
    // no               // Doesn't appear to be used

    weightUpdatePeriod = 50.0; // Period between updating the weights
    relaxation = 1E-5;  // GenerativeConn rule: A(new) = A(old) + relaxation*dA/dt
};

HyPerConn "One to many original map" = {
    nxp = 30;           // Number of horizontal pixels in each patch
    nyp = 30;           // Number of vertical pixels in each patch
    nfp = 2;            // Number of features in each patch

    stdpFlag = 0;       // Whether to use spike timing dependent plasticity
    // ampLTP           // Used to update plasticity increment pIncr
    // ampLTD           // Used to update plasticity decrement pDecr
    // tauLTP           // Used to update plasticity increment pIncr
    // tauLTD           // Used to update plasticity decrement pDecr
    
    // strength = 1;       // Used in Gaussian weights and normalizeWeights
    // aspect = 3;         // Used in Gaussian weights: aspect ratio
    // sigma = 3;          // Used in Gaussian weights: standard deviation
    // rMax = 3;           // Used in Gaussian weights
    // numFlanks = 1;      // Used in Gaussian weights
    // flankShift = 0;     // Used in Gaussian weights
    // rotate = 0;         // Used in Gaussian weights
    
    // wMax             // Used in updating weight patches
                        // If wMax is not present and strength is, use strength for wMax
    // wMin             // Used in updating weight patches
    // dWMax            // Used in updating weight patches
    
    // normalize        // Whether to normalize weights during initialization
    // normalize_max    // Used to normalize if normalize flag is set
    // normalize_zero_offset  // Used to normalize if normalize flag is set
    
    initFromLastFlag = 0; // Whether to initialize wgts w/ previous run's data
    
    randomFlag = 1;     // Whether to initialize with random weights
    uniformWeights = 1; // If initializing w/ random weights, use uniform dist.
    gaussianWeights = 0; // If initializing w/ random weights, use Gaussian dist.
                        // Exactly one of uniformWeights and gaussianWeights
                        // must be set (Defaults are U=true, G=false)
    // wMinInit         // For uniform dist. random weights, the minimum value
    // wMaxInit         // For uniform dist. random weights, the maximum value
    // wGaussMean       // For Gaussian dist. random weights, the mean
    // wGaussStdev      // For Gaussian dist. random weights, the std. dev.
    
    smartWeights = 0;   // Whether to call HyPerConn::smartWeights.

    // writeStep        // How often to write updates; not used yet
    // delay            // Doesn't appear to be used
    // fixDelay         // Doesn't appear to be used
    // vel              // Doesn't appear to be used
    // rmin             // Doesn't appear to be used
    // rmax             // Doesn't appear to be used
    // varDelayMin      // Doesn't appear to be used
    // varDelayMax      // Doesn't appear to be used
    // numDelay         // Not used as params->numDelay is set to
                        // params->varDelayMax - params->varDelayMin + 1,
                        // and then params->numDelay isn't used anyway
    // isGraded         // Doesn't appear to be used
    
    // no               // Doesn't appear to be used

    weightUpdatePeriod = 50.0; // Period between updating the weights
    relaxation = 1E-5;  // GenerativeConn rule: A(new) = A(old) + relaxation*dA/dt
};

HyPerConn "Many to one transpose" = {
    initFromLastFlag = 0; // Whether to initialize wgts w/ previous run's data
    // For feedback connections, other parameters will be inferred from the
    // associated feedforward connection 
};

HyPerConn "Many to one transpose" = {
    initFromLastFlag = 0; // Whether to initialize wgts w/ previous run's data
    // For feedback connections, other parameters will be inferred from the
    // associated feedforward connection 
};
