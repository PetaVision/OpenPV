// params-testcheckPatchSize.pv
//
// Created on: Dec 2, 2010
//     Author: pschultz

// params-generativelateral.pv
//     input parameters file for generative model with lateral connections

FileDefinition "ImageFileList" =  "./input/filenames.txt";
FileDefinition "OutputDir" =      "./output/generativelateral/"; // not used yet

HyPerCol "column" = {
    nx = 32;            // number of horizontal pixels in the column
    ny = 32;            // number of vertical pixels in the column
    dt = 1;              // time increment per timestep
    randomSeed = 0;     // seed the column's random number generator.
};

// 3 layers:  Slideshow,
//            Retina,
//            Layer A,

HyPerLayer "Slideshow" = {
    restart = 0;        // whether to load *_last.pvp files at initialization
    nxScale = 1;        // scale factor between layer size and column size
    nyScale = 1;        // layer size = n{x,y}Scale * (column size)
    nf = 1;             // Number of features.  For images, use nf=3 for RGB
    marginWidth = 0;    // Width of margin padding in pixels
    // writeStep        // How often to write updates; not used yet
    mirrorBCflag = 0;   // Whether to use mirror boundary conditions at edges
    spikingFlag = 0;    // Whether there is spiking
    writeNonspikingActivity = 1;
        // Whether to write activity at each step in the nonspiking case 
    
    displayPeriod = 20; // Length of time each image in the movie is presented.
    persistenceProb = 1;// Probability of no jitter when updateImage is called
    // recurrenceProb   // Probability that offset returns to bias position
    stepSize = 0;       // Amount of jitter each direction when jitter occurs
    biasChangeTime = 10000; // How often to update bias position
    writePosition = 0;  // Whether to write bias and offset to image-pos.txt
    randomMovie = 0;    // Whether to call randomFrame()
    // randomMovieProb  // If randomMovie != 0, prob that a given pixel is 1.
    offsetX = 0;        // Initial horizontal offset into image
    offsetY = 0;        // Initial vertical offset into image
};

HyPerLayer "Retina" = {
    restart = 0;        // whether to load *_last.pvp files at initialization
    nxScale = 1;        // scale factor between layer size and column size
    nyScale = 1;        // layer size = n{x,y}Scale * (column size)
    nf = 1;             // Number of features.  For images, use nf=3 for RGB
    marginWidth = 3;    // Width of margin padding in pixels
    writeStep = 1.0;    // How often to write updates; not used yet
    mirrorBCflag = 1;   // Whether to use mirror boundary conditions at edges
    spikingFlag = 0;    // Whether there is spiking
    writeNonspikingActivity = 1;
        // Whether to write activity at each step in the nonspiking case 
    
    // fireOffPixels    // Currently commented out
    // invert           // In deprecated or obsolete sections
    // uncolor          // In deprecated or obsolete sections
    poissonEdgeProb = 1; 
    poissonBlankProb = 0;
    burstFreq = 1;
    burstDuration = 40000;
    // noiseOnFreq      // If present, poissonEdgeProb set to
                        // min(1, noiseOnFreq * parent column's dt);
                        // overrides setting poissonEdgeProb in this file
    // noiseOffFreq     // If present, poissonBlankProb set to
                        // min(1, noiseOffFreq * parent column's dt);
                        // overrides setting poissonBlankProb in this file
    beginStim = 1;
    endStim = 40000;
};


HyPerLayer "Layer A" = {
    restart = 0;        // whether to load *_last.pvp files at initialization
    nxScale = 0.5;        // scale factor between layer size and column size
    nyScale = 1;        // layer size = n{x,y}Scale * (column size)
    nf = 4;            // Number of features.  For images, use nf=3 for RGB
    marginWidth = 8;   // Width of margin padding in pixels
    writeStep = 1.0;    // How often to write updates; not used yet
    mirrorBCflag = 1;   // Whether to use mirror boundary conditions at edges
    spikingFlag = 0;    // Whether there is spiking
    writeNonspikingActivity = 1;
        // Whether to write activity at each step in the nonspiking case

    Vrest = 0.0;     // Sets initial value of clayer->V
    // Vexc             // Only used by updateFunc, which doesn't get called
    // Vinh             // Only used by updateFunc, which doesn't get called
    // VinhB            // Only used by updateFunc, which doesn't get called
    // tau              // Only used by updateFunc, which doesn't get called
    // tauE             // Only used by updateFunc, which doesn't get called
    // tauI             // Only used by updateFunc, which doesn't get called
    // tauIB            // Only used by updateFunc, which doesn't get called
    // VthRest          // Sets initial value of clayer->Vth
    // tauVth           // Only used by updateFunc, which doesn't get called
    // deltaVth         //
    noiseAmpE = 0.0;    // If positive, adds random noise to V,Vth,G[k];
                        // also initial value of clayer->G_E
    noiseAmpI = 0.0;    // If positive, adds random noise to V,Vth,G[k];
                        // also initial value of clayer->G_E
    // noiseAmpIB       // Sets initial value of clayer->G_IB
                        // if either noiseAmpE or noiseAmpI is positive
    // noiseFreqE       // Only used by updateFunc, which doesn't get called
    // noiseFreqI       // Only used by updateFunc, which doesn't get called
    // noiseFreqIB      // Only used by updateFunc, which doesn't get called
};


// 2 connections:  Slideshow to Retina
//                  Retina to Layer A

HyPerConn "Slideshow to Retina" = {
    nxp = 1;            // Number of horizontal pixels in each patch
    nyp = 1;            // Number of vertical pixels in each patch
    nfp = 1;            // Number of features in each patch

    stdpFlag = 0;       // Whether to use spike timing dependent plasticity
    // ampLTP           // Used to update plasticity increment pIncr
    // ampLTD           // Used to update plasticity decrement pDecr
    // tauLTP           // Used to update plasticity increment pIncr
    // tauLTD           // Used to update plasticity decrement pDecr
    
    strength = 1.0;     // Used in Gaussian weights and normalizeWeights
    aspect = 1;         // Used in Gaussian weights: aspect ratio
    sigma = 1;          // Used in Gaussian weights: standard deviation
    rMax = 1;           // Used in Gaussian weights
    numFlanks = 1;      // Used in Gaussian weights
    flankShift = 0;     // Used in Gaussian weights
    rotate = 0;         // Used in Gaussian weights
    
    // wMax             // Used in updating weight patches
                        // If wMax is not present and strength is, use strength for wMax
    // wMin             // Used in updating weight patches
    // dWMax            // Used in updating weight patches
    
    // normalize        // Whether to normalize weights during initialization
    // normalize_max    // Used to normalize if normalize flag is set
    // normalize_zero_offset  // Used to normalize if normalize flag is set
    
    initFromLastFlag = 0; // Whether to initialize wgts w/ previous run's data
    
    randomFlag = 0;     // Whether to initialize with random weights
    // uniformWeights   // If initializing w/ random weights, use uniform dist.
    // gaussianWeights  // If initializing w/ random weights, use Gaussian dist.
                        // Exactly one of uniformWeights and gaussianWeights
                        // must be set (Defaults are U=true, G=false)
    // wMinInit         // For uniform dist. random weights, the minimum value
    // wMaxInit         // For uniform dist. random weights, the maximum value
    // wGaussMean       // For Gaussian dist. random weights, the mean
    // wGaussStdev      // For Gaussian dist. random weights, the std. dev.
    
    smartWeights = 0;   // Whether to call HyPerConn::smartWeights.

    // writeStep        // How often to write updates; not used yet
    // delay            // Doesn't appear to be used
    // fixDelay         // Doesn't appear to be used
    // vel              // Doesn't appear to be used
    // rmin             // Doesn't appear to be used
    // rmax             // Doesn't appear to be used
    // varDelayMin      // Doesn't appear to be used
    // varDelayMax      // Doesn't appear to be used
    // numDelay         // Not used as params->numDelay is set to
                        // params->varDelayMax - params->varDelayMin + 1,
                        // and then params->numDelay isn't used anyway
    // isGraded         // Doesn't appear to be used
    
    // no               // Doesn't appear to be used
};

HyPerConn "Retina to Layer A" = {
    nxp = 3;            // Number of horizontal pixels in each patch
    nyp = 1;            // Number of vertical pixels in each patch
    nfp = 4;            // Number of features in each patch

    stdpFlag = 0;       // Whether to use spike timing dependent plasticity
    // ampLTP           // Used to update plasticity increment pIncr
    // ampLTD           // Used to update plasticity decrement pDecr
    // tauLTP           // Used to update plasticity increment pIncr
    // tauLTD           // Used to update plasticity decrement pDecr
    
    strength = 1.0;     // Used in Gaussian weights and normalizeWeights
    aspect = 1;         // Used in Gaussian weights: aspect ratio
    sigma = 1;          // Used in Gaussian weights: standard deviation
    rMax = 1;           // Used in Gaussian weights
    numFlanks = 1;      // Used in Gaussian weights
    flankShift = 0;     // Used in Gaussian weights
    rotate = 0;         // Used in Gaussian weights
    
    // wMax             // Used in updating weight patches
                        // If wMax is not present and strength is, use strength for wMax
    // wMin             // Used in updating weight patches
    // dWMax            // Used in updating weight patches
    
    // normalize        // Whether to normalize weights during initialization
    // normalize_max    // Used to normalize if normalize flag is set
    // normalize_zero_offset  // Used to normalize if normalize flag is set
    
    initFromLastFlag = 0; // Whether to initialize wgts w/ previous run's data
    
    randomFlag = 0;     // Whether to initialize with random weights
    // uniformWeights   // If initializing w/ random weights, use uniform dist.
    // gaussianWeights  // If initializing w/ random weights, use Gaussian dist.
                        // Exactly one of uniformWeights and gaussianWeights
                        // must be set (Defaults are U=true, G=false)
    // wMinInit         // For uniform dist. random weights, the minimum value
    // wMaxInit         // For uniform dist. random weights, the maximum value
    // wGaussMean       // For Gaussian dist. random weights, the mean
    // wGaussStdev      // For Gaussian dist. random weights, the std. dev.
    
    smartWeights = 0;   // Whether to call HyPerConn::smartWeights.

    // writeStep        // How often to write updates; not used yet
    // delay            // Doesn't appear to be used
    // fixDelay         // Doesn't appear to be used
    // vel              // Doesn't appear to be used
    // rmin             // Doesn't appear to be used
    // rmax             // Doesn't appear to be used
    // varDelayMin      // Doesn't appear to be used
    // varDelayMax      // Doesn't appear to be used
    // numDelay         // Not used as params->numDelay is set to
                        // params->varDelayMax - params->varDelayMin + 1,
                        // and then params->numDelay isn't used anyway
    // isGraded         // Doesn't appear to be used
    
    // no               // Doesn't appear to be used
};
