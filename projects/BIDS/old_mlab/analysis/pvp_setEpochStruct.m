function [epoch_struct, layer_struct] = ...
      pvp_setEpochStruct(epoch_struct, ...
			 layer, ...
			 layer_struct, ...
			 num_epochs)

  global BIN_STEP_SIZE DELTA_T
  global BEGIN_TIME END_TIME 
  global STIM_END_TIME
  global STIM_BEGIN_STEP STIM_END_STEP
  global STIM_BEGIN_BIN STIM_END_BIN

  %% get adjusted begin/end times from spike array
  disp('opening sparse spikes');
  [fid, ...
   pvp_header, ...
   pvp_index, ...
   total_spikes, ...
   total_steps,...
   exclue_spikes,...
   exclude_steps, ...
   exclude_offset ] = ...
      pvp_openSparseSpikes(layer);
  fclose(fid);

  %% set layer dimensions from header
  layer_struct.num_features(layer) = pvp_header(pvp_index.NF);
  layer_struct.num_cols(layer) = ...
  	pvp_header(pvp_index.NX_GLOBAL);
  layer_struct.num_rows(layer) = ...
  	pvp_header(pvp_index.NY_GLOBAL) ;
  layer_struct.num_neurons(layer) = ...
      layer_struct.num_features(layer) * ...
      layer_struct.num_cols(layer) * ...
      layer_struct.num_rows(layer);
   layer_struct.size_layer{layer} = ...
      [layer_struct.num_features(layer), ...
       layer_struct.num_cols(layer), ...
       layer_struct.num_rows(layer)];

  epoch_struct.time_origin(layer) = BEGIN_TIME;
  
  epoch_struct.begin_time(:,layer) = BEGIN_TIME;
  epoch_struct.end_time(:,layer) = END_TIME;
  epoch_struct.exclude_offset(:,layer) = exclude_offset;
    
  %% fit equal number of time steps and PSTH bins in each epoch
  total_time = END_TIME - BEGIN_TIME + DELTA_T;
  epoch_struct.sum_total_time(layer) = total_time;
  epoch_struct.sum_total_steps(layer) = total_steps;
  epoch_struct.sum_total_spikes(layer) = total_spikes;
  epoch_time = floor( total_time / num_epochs );
  epoch_steps = floor( total_steps / num_epochs );
  if total_steps > num_epochs * epoch_steps
    total_steps =  num_epochs * epoch_steps;
  endif %%
  begin_step = 1;
  end_step = epoch_steps;
  time_steps = begin_step:end_step;
  
  epoch_bins = floor( epoch_steps / BIN_STEP_SIZE );
  epoch_steps = epoch_bins * BIN_STEP_SIZE;
  time_bins = (1:epoch_bins)*BIN_STEP_SIZE*DELTA_T;
  
  epoch_struct.epoch_time(layer) = epoch_time;
  epoch_struct.epoch_steps(layer) = epoch_steps;
  epoch_struct.epoch_bins(layer) = epoch_bins;
  
 
%% set stim_begin/stim_end vals
  epoch_struct.stim_begin_step(layer) = abs( STIM_BEGIN_STEP );
  epoch_struct.stim_begin_bin(layer) = abs( STIM_BEGIN_BIN );
  epoch_struct.stim_end_step(layer) = ...
      epoch_struct.epoch_steps(layer) - abs( STIM_END_STEP );
  epoch_struct.stim_end_bin(layer) = ...
      epoch_struct.epoch_bins(layer) - abs( STIM_END_BIN );
%  epoch_struct.stim_steps(layer) = ...
%      epoch_struct.stim_begin_step(layer) : epoch_struct.stim_end_step(layer);
%  epoch_struct.stim_bins(layer) = ...
%      epoch_struct.stim_begin_bin(layer) : epoch_struct.stim_end_bin(layer);

  %% start loop over epochs
  for i_epoch = 1 : num_epochs
    disp(['i_epoch = ', num2str(i_epoch)]);
    
    %% init BEGIN/END times for each epoch
    epoch_struct.begin_time(i_epoch, layer) = ...
        epoch_struct.time_origin(layer) + ...
        ( i_epoch - 1 ) * epoch_time;
    BEGIN_TIME = epoch_struct.begin_time(i_epoch, layer);
    epoch_struct.end_time(i_epoch,layer) = BEGIN_TIME + epoch_time;
    END_TIME = epoch_struct.end_time(i_epoch, layer);
    
    %% determine offsets, etc for this epoch
    [fid, ...
     pvp_header, ...
     pvp_index, ...
     total_spikes, ...
     total_steps,...
     exclude_spikes,...
     exclude_steps, ...
     exclude_offset ] = ...
        pvp_openSparseSpikes(layer);

    epoch_struct.exclude_offset(i_epoch,layer) = exclude_offset;
    epoch_struct.total_spikes(i_epoch,layer) = total_spikes;
    epoch_struct.total_steps(i_epoch,layer) = total_steps;
  endfor %% % i_epoch
